\section{Реализация решения}

Для осуществления поддержки динамической типизации для компилятора Kotlin в JVM, необходимо её поддержать с двух сторон:

\begin{enumerate}
    \item Требуется разработка изменений в компиляторе, которые будут в тех местах, где осуществление типизации отложено до момента выполнения, реализовать вызов динаимических инструкций.
    \item Необходимо предоставить библиотеку, которая предоставляет набор загрузочных методов, которые выполняют необходимое динаимическое связывание в требуемых случаях - при вызове методов и при чтении или записи в поля.
\end{enumerate}




\subsection{Технические особенности}

Рассмотрим детали реализации языков Kotlin и Java, которые нам понадобятся в настоящей работе.

\subsubsection{Связь языка Java и Kotlin}
\label{sec:connectKotlinWithJava}
    
В языке Java --- 8 примитивных типов. Им соответствуют свои типы в Kotlin, согласно таблице \ref{tab:primitiveKotlinVsJava}. Однако, аналоги примитивных типов, в языке Kotlin, существуют только в момент компиляции. Для улучшения производительности, в процессе компиляции, они заменяются своими аналогами на Java, и отсутствуют во время выполнения как таковые. Выбор, заменить аналог в Kotlin на примитивный тип Java или на ссылочную обёртку, компилятор Kotlin выполняет самостоятельно.
В Java также существует вспомогательный примитивный тип \textit{void}. Он отличается тем, что мы не можем создавать его экземпляр. В Kotlin для него существует аналог - тип \textit{Unit}. Он не является примитивным, и у него есть один экземпляр. Для оптимизации производительности, в Kotlin, если функция возвращает значение типа \textit{Unit}, то на уровне Java байт-кода, она преобразуется в функцию, которая ничего не возвращает \textit{void}. Однако, с точки зрения языка, мы возвращаем из функции объект типа \textit{Unit}, и мы можем производить на нём какие-то действия. Поэтому, для корректности, в месте использования возвращённого \textit{Unit} значения, мы загружаем тот самый, единственный экземпляр типа \textit{Unit} из стандартной библиотеки. Так как возвращённое \textit{Unit} значение используется не всегда, это позволяет улучшить производительность.



\begin{table}[h]
\caption{\label{tab:primitiveKotlinVsJava}Соответствие примитивных типов}
\begin{center}
\begin{tabular}{|c|l|l|}
\hline
Примитивный тип Java & Ссылочная обёртка Java & Аналог Kotlin \\
\hline
boolean  & java.lang.Boolean  & kotlin.Bool  \\
byte  & java.lang.Byte & kotlin.Byte \\
char  & java.lang.Character & kotlin.Char \\
short  & java.lang.Short & kotlin.Short \\
int & java.lang.Integer & kotlin.Int \\
long &  java.lang.Long & kotlin.Long \\
float & java.lang.Float & kotlin.Float \\
double & java.lang.Double & kotlin.Double \\
\hline
\end{tabular}
\end{center}
\end{table}



Объекты класса и всевозможные переменные массива являются ссылочными типами данных. Все классы объединены в общую иерархию наследования. На вершине иерархии находится тип \textit{Object}, все остальные наследуются от него, или, говоря иначе, \textit{Object} является их \textit{родителем}. Также, любой класс, может быть передан в любое место программы, в котором ожидается его родительский класс. В языке Kotlin аналогом типа \textit{Object} является тип \textit{Any}. Каждый класс языка Kotlin, является наследником \textit{Any}. При компиляции, этот класс превращается в \textit{Object}.
Особым значением, которое может храниться в любой ссылочной переменной в Java, является \textit{null}. Это значение показывает что в данной переменной не лежит никакого значения. В языке Kotlin, чтобы разрешить хранение в переменной \textit{null} значения, необходимо приписать к её типу <<?>>. Например, любое значение можно положить в переменную типа <<\textit{Any?}>>.
%Также в Java есть ссылочные типы. У нас есть возможность создавать динамические объекты.

Для каждого примитивного типа в Java, существует его ссылочная обёртка. Java поддерживает автоматические преобразования между ними, такой процесс называется \textit{автоупаковка и распаковка}.

В языке Kotlin есть ещё набор типов, которые, как и примитивные типы, перестают существовать после процесса компиляции. Все они перечислены в таблице \ref{tab:kotlinTypeConversion}.

\begin{table}[h]
\caption{\label{tab:kotlinTypeConversion}Преобразование типов языка Kotlin}
\begin{center}
\begin{tabular}{|l|l|}
\hline
Тип в языке Kotlin & Преобразованный тип в Java \\
\hline
java.lang.String & kotlin.String \\
boolean[]  & BooleanArray  \\
byte[]  & ByteArray \\
char[]  & CharArray \\
short[]  & ShortArray \\
int[] & IntArray \\
long[] &  LongArray \\
float[] & FloatArray \\
double[] & DoubleArray \\
\hline
\end{tabular}
\end{center}
\end{table}

\subsubsection{Осуществление вызовов и Java платформа}

В языке Java поля и методы можно разделить на две группы \cite{java:horstmann2012core}. Обычные поля ассоциированы с конкретным экземпляром класса - объектом. С другой стороны, статические поля ассоциированы с классом, и общие для всех его экземпляров. Внутри статических методов мы имеем право взаимодействовать только со статическими полями. Обычные методы имеют право взаимодействовать как с полями текущего экземпляра класса, так и со статическими полями данного класса. Важно заметить, что статичность поля или метода никак не связано со статическим разрешением вызова. В языке Java, на этапе компиляции можно определить, осуществляем мы вызов статического или обычного метода класса (поля), таким образом все вызовы разрешаются статически.

Для осуществления статически разрешаемых вызовов методов и взаимодействия с полями, в байт-коде Java предназначены следующие инструкции \cite{book:yellin1996java}:

\begin{itemize}
    \item \textbf{invokespecial} --- используется для создания новых экземпляров классов, вызовов приватных методов, и методов родительского класса.
    \item \textbf{invokestatic} --- используется для вызова статических методов
    \item \textbf{invokeinterface} --- используется для вызова методов интерфейса.
    \item \textbf{invokevirtual} --- используется для вызова всех остальных методов.
    \item \textbf{getfield}, \textbf{getstatic} --- используется для получения поля объекта или поля класса соответственно.
    \item \textbf{putfield}, \textbf{putstatic} --- используется для установки значения поля объекта или поля класса соответственно.
\end{itemize}


Для поддержки динамических языков на платформе JVM, в JSR 292, была предложена новая байт-код инструкция \textit{invokedynamic}, которая поддерживает эффективное и гибкое решение выполнения вызовов, в условиях отсутствия статической информации о типах \cite{java:JSR292rosejsr}.

Инструкция \textit{invokedynamic} осуществляет вызов метода, на который ссылается специальный объект, называемый точкой вызова (call site). Этот объект получается путём вызова специальной загрузочного метода (bootstrap method), ассоциированного с каждой \textit{invokedynamic} инструкцией \cite{book:yellin1996java}. Путём создания специального алгоритма поведения загрузочного метода, у нас появляется возможность, во время выполнения программы, подстраиваясь под актуальную типовую информацию, производить вызов нужных методов.


В языке Java поддерживается \textit{рефлексия} --- механизм исследования данных о программе, во время её выполнения. Она осуществляется при помощи Java Reflection API. Основной список информации, который можно получить с помощью интерфейса API \cite{java:forman2004javaReflectionsInAction}:
%С его помощью, можно получить информацию об ок типе объекта во время исполнения, получить 

\begin{itemize}
    \item Определить класс объекта во время исполнения.
    \item Получить список полей и методов класса.
    \item Получить информацию о типах аргументов метода.
    \item Вызвать требуемый метод с конкретными аргументами.
\end{itemize}

Однако, стоит отменить, что некоторые операции Reflection API выполняются долгое время.


В языке Kotlin, для любого объекта можно обеспечить возможность быть вызванным. Для этого, в его классе достаточно описать оператор \textit{invoke} --- специальный метод, который помечен ключевым словом \textit{operator}. Таким образом, вызов \mintinline{kotlin}{a(i_1, ..., i_N)} будет преобразован в вызов \mintinline{kotlin}{a.invoke(i_1, ..., i_N)}.

В языках Kotlin и Java поддерживаются перегрузки методов --- возможность определить несколько методов с одним и тем же именем, которые имеют разное число или разные типы аргументов. Также поддерживаются методы с переменным числом аргументов. Со стороны Java платформы, в месте вызова аргументы упаковываются в массив (набор элементов расположенных непрерывно в памяти) и передаются в вызываемую функцию. На стороне вызываемой функции, работа с переданными аргументами не отличается от ситуации, если бы был передан массив.








\subsection{Реализация поддержки динамических вызовов на стороне компилятора}
\label{sec:compileRealization}

Благодаря тому что при компиляции Kotlin в JavaScript, уже поддерживаются динамические вызовы, первая задача решается определение того кода, который мы будем генерировать при компиляции в байт код Java. Мы это будем делать при помощи инструкции \textit{invokedynamic}.
%Рассмотрим подробнее её синтаксис.

%СИНТАКСИС.

Первым аргументом этой инструкции мы передадим идентификатор действия, согласно таблице \ref{tab:DynamicCallType}. 

\begin{table}[h]
\caption{\label{tab:DynamicCallType}Идентификаторы динамического действия}
\begin{center}
\begin{tabular}{|c|l|}
\hline
Идентификатор	& Требуемое действие \\
\hline
getField & Получение значение поля или свойства класса  \\
setField & Установка нового значения поля или свойства класса	\\
invoke   & Вызов метода или объекта умеющего обработать вызов  \\
\hline
\end{tabular}
\end{center}
\end{table} 

Вторым аргументом нам необходимо передать ожидаемый тип метода, который мы хотим получить в результате вызова. Этот тип мы можем составить во время компиляции, путём составления \textit{дескриптора метода}, согласно правилам описанным в главе 4.3 Descriptors \cite{book:yellin1996java}. Несмотря на то, что во время компиляции мы не знаем будущие типы, которые будут лежать в \textit{dynamic}-переменных во время исполнения, мы универсально можно приравнять их к переменным типа \textit{Object}, и использовать его сигнатуру в дескрипторе.

Третим аргументом является \textit{загрузочный метод}, реализация которого будет рассмотрена в главе \ref{sec:dynamicLibrary}.

Четвёртым аргументом пойдёт имя метода или или поля, оно нам понадобится для осуществления поиска требуемого метода во время выполнения программы.

В языке Kotlin поддерживается использование аргументов по умолчанию. Это означает что части последних аргументов метода мы можем указать значение по умолчанию. Тогда мы получаем возможность опускать часть последних аргументов \cite{book:jemerov2017kotlininAction}. При вызове метода с меньшим числом аргументов, компилятор осуществит вызов специально сгенерированного для этого метода помощника, который подготовит все недостающие аргументы метода, вычислив их согласно значениям по умолчанию. После этого, помощник осуществит вызов требуемого метода, так как для этого вызова у него уже будут все аргументы.

Аргументы по умолчанию являются мощным инструментом в сочетании с другой возможностью языка --- именованные аргументы. В аргументах по умолчанию, если мы не имели возможность опускать произвольные аргументы, имеющие значение по умолчанию. Если мы опустили какой-то аргумент метода, то следующие мы тоже должны были опустить, потому что компилятор не мог понять какой именно аргумент мы хотим передать. Одним из способов решения этой проблемы являются именованные аргументы. Мы можем пометить приписать части параметров имя аргумента в вызываемого метода, в качестве которого мы хотим передать текущий параметр \cite{book:jemerov2017kotlininAction}. Для того чтобы избежать неопределённостей, все именованные аргументы должны тоже идти последними.

Заметим что если мы хотим поддержать именованные аргументы в динамическом вызове, нам необходимо сохранить все метки имён аргументов до момента разрешения динамического вызова. Для этого мы их передадим в качестве последних аргументов в \textit{invokedynamic} инструкцию. Заметим, что поскольку именованные аргументы всегда находятся последними, нам не нужно сохранять соотвествие между именами аргументов и переданными значениями, и мы их сможем однозначно восстановить во время выполнения.


\subsection{Реализация библиотеки для поддержки динамического связывания}
\label{sec:dynamicLibrary}

Рассмотрим основные компоненты библиотеки, которую нам потребуется реализовать:

\begin{itemize}
    \item Загрузочный метод.
    \item Механизм динамического разрешения перегрузок.
    \item Методы выполняющие настройку точки вызова для различных типов динамических операций.
    \item Механизм кеширующего взаимодействия с лежащими в полях или свойствах класса вызываемыми объектами.
    \item Маркер выполнения операции составного присваивания.
\end{itemize}

Детальней рассмотрим каждую из этих компонент.

\subsubsection{Загрузочный метод}

Основная задача загрузочного метода состоит в том, чтобы в зависимости от требуемого динамического действия, обеспечить вовзращение объекта, в котором лежит точка вызова, с соответствующей действию ссылкой на метод. Для этого, в качестве параметров мы получаем специальный объект типа \textit{MethodHandles.Lookup}, который будет осуществлять проверку разрешений доступа --- возможен ли из текущего места вызова, доступ к выбранному методу или полю и свойству класса. Также мы получаем все параметры, которые мы передали в \textit{invokedynamic} инструкцию при компиляции, согласно главе \ref{sec:compileRealization}.

В самой загрузочного метода, мы перебираем все типы динамических  действий согласно таблице \ref{tab:DynamicCallType}, и выбираем нужный метод-настройщик. После его установки, он будет вызван с актуальными аргументами пользовательского вызова. Заметим, что при вызове метода-настройщика, мы можем потерять знания переданные в загрузочный метод. В данный момент мы ещё не можем осуществить поиск нужного метода или поля, потмоу что мы не знаем актуальных параметров времени выполнения. Поэтому определения целевого метода или поля и свойства класса, необходимо осуществлять в методе-настройщике. Но там нам также понадобится объект типа \textit{MethodHandles.Lookup}, для осуществления проверки корректности прав доступа. Поэтому, мы воспользуемся механизмом  \textit{MethodHandles.insertArguments} \cite{javadoc:MethodHandlesLookup}. С его помощью мы получим ссылку на метод, которому можно будет передать аргументы в соответствии с ожидаемым типом аргументом, который мы запросили при генерации \textit{invokedynamic} инструкции, который при этом в себе вызывает нашу метод-настройщик, и передаёт в неё необходимые в дальнейшем аргументы из загрузочного метода. В дальнейшем нам понадобятся следующие объекты:
\begin{itemize}
    \item Точка вызова.
    \item Объект типа \textit{MethodHandles.Lookup}.
    \item Ожидаемый тип ссылки на метод.
    \item Имя вызываемого метода или поля и свойства класса.
    \item Именованные аргументы (только при осуществлении вызова метода).
\end{itemize}


\subsubsection{Механизм динамического разрешения перегрузок}
\label{realization:dynamicResolve}

В настоящий момент, всё разрешение методов в компиляторе языка Kotlin, при компиляции в байт код Java, происходит во время компиляции, основываясь на тех знания о типах, которые мы имеем во время компиляции. Для осуществления динамического связывания, необходимо разработать инструмент, который на основании имени метода, и всех его параметров, основываясь, на типовой информации времени выполнения, получит ссылку на метод который требуется вызвать. Данный механизм должен поддерживать выбор метода с учётом её перегрузок, он должен принимать во внимание методы с переменным числом аргументов, методы с аргументами по умолчанию, а также вызов метода с использованием именованных аргументов.

Предположим, у нас осуществляется следующий динамический вызов:

\begin{minted}[mathescape,
               linenos,
               numbersep=5pt,
               gobble=2,
               frame=lines,
               framesep=2mm]{kotlin}
    receiver.method(arg1, ..., argN)
\end{minted}

Алгоритм разрешения перегрузок можно описать следующим образом:

\begin{enumerate}
    \item Получить список всех методов, которые есть у типа, который в момент выполнения находится в переменной \textit{receiever}.
    \item Удалить все методы, имя которых не подходит.\label{itm:del1}
    \item Удалить те методы, тип которых не подходит к актуальным аргументам динамического вызова.\label{itm:del2}
    \item Если полученный набор методов пуст, то попробовать осуществить шаги \label{itm:del1}-\label{itm:del2} на наборе встроенных методов.
    \item Среди оставшихся методов выбрать наиболее специфичный, по сравнению с другими.
    \item Если наиболее специфичный метод не найден, то завершить поиск с ошибкой.
    \item Проверить согласованность с правами доступа.
    \item При необходимости учесть аргументы по умолчанию и именованные аргументы.
    \item Завершить алгоритм, вернув результирующую ссылку на метод
\end{enumerate}

Остановимся подробнее на реализации этих пунктов. Для поиска всех методов класса можно использовать механизм Java Reflection API. Однако, не все методы мы сможем найти. Как мы обсуждали в главе \ref{sec:connectKotlinWithJava}, некоторых типов языка Kotlin, не существует во время выполнения, и все они превращаются в соотвествующие им типы Java. Однако, у типов Java уже не будет всех методов, которые мы могли вызвать у аналога из Kotlin. Поэтому нам необходимо реализовать \textit{библиотеку встроенных методов}, в которой присутствуют все недостоющие методы, и при необходимости, выполнять разрешения в пользу методов данной библиотеки. Результатом поиска с использованием Java Reflection API, будет массив объектов-кандидатов типа \textit{Method} или 
\textit{Field} для методов и полей соответственно.

Полученный список методов или полей нам необходимо отфильтровать, удалив из них все те поля, которые имеют неподходящее имя. Стоит учесть, что для поддержки разрешения методов, у которых есть значения по умолчанию, то как говорилось в главем \ref{sec:compileRealization}, необходимо учесть наличие метода-помощника. От оригинального метода его отличает наличие суффикса \textit{\$default}, и большее количество аргументов. В метод-помощник дополнительно передаются спеиальные битовые маски, в которых анализируя установленные биты, можно понять, какие аругменты необходимо вычислить, согласно их значениям по умолчанию.

При отборе тех методов, чьи параметры удовлетворяют актуальным аругментом динамического стоит ориентироваться на несколько моментов. Во первых, быстрым критерием отбора является количество аргументов метода. Оно должно совпадать с количеством переданных динамических аргументов, однако, отдельно стоит обработать случаи, когда у метода переменное число аргументов, и когда есть аргументы по умолчанию. Для проверки возможности передать объект в качестве нужного аргумента, необходимо проверить отличаются ли их типы с точностью до упаковки и распаковки, либо они удовлетворяют ограничениям иерархии наследования. Для проверки последнего, в Java Reflection API присутствует метод \textit{isAssignableFrom()}.

Для проверки согласованности прав доступа, нам понадобится заранее сохранённый объект типа \textit{MethodHandles.Lookup}. Благодаря ему, по имеющемуся у нас объекту типа \textit{Method}, с помощью метода \textit{unreflect}, мы можем получить ссылку на метод, которую в дальнейшем установим нашей точке вызова. В случае поле, то с помощью методов \textit{unreflectGetter} и 
\textit{unreflectSetter}, мы можем объект типа \textit{Field}, также преобразовать в ссылку на нужный метод чтения или метод записи.

Если у нас есть аргументы по умолчанию то вызов будет происходить при помощи метода-помощника. Нам необходимо будет создать ссылку на такой метод, который в качестве параметров, в качестве которых мы хотим использовать значение по умолчанию, перадавалось какое-то значение подходящего типа. А после всех параметров, передавались битовые маски, установленные биты которых, будут показывать позиции аргументов, которые мы попросим вычислить метод-помощник. Битовые маски будут передаваться в качестве 32-х битных целых чисел. Таким образом, одно такое число может характеризовать 32 аргумента. Обратим внимание, что при большем количестве аргументов, нам потребуется передавать больше чисел. Для передачи значений нужного типа и битовых масок, мы буем использовать \textit{MethodHandles.insertArguments}. Для получения какого-то значения требуемого типа, мы можем перебрать тип аргумента, и для типа boolean вернуть false, для числовых типов вернуть пердставление нуля в целевом типе, а для ссылочних типов вернут null.
При передаче именованных аргументов, нам необходимо создать ссылку на такой метод, который будет переставлять аргументы на нужные места, и после вызывать целевой метод. Для этого нам понадобится метод \textit{MethodHandles.permuteArguments}.

При запросе разрешения имени поля и свойства, важным моментом является выработка осознания того, что перед нами - поле или свойство класса. Предположим динамический вызов выглядит так:

\begin{minted}[mathescape,
               linenos,
               numbersep=5pt,
               gobble=2,
               frame=lines,
               framesep=2mm]{kotlin}
    receiver.field
\end{minted}

Однако, мы точно не знаем, это поле \textit{field} класса или свойство \textit{field} класса. Если это является свойством класса, то необходимо осуществлять доступ посредством специального \textit{метода чтения}, который будет выглядеть как метод с именем \textit{getField()}. Таким образом, у нас возможна одна из трёх ситуаций, каждую из котоорых мы должны обработать:

\begin{itemize}
    \item У типа, который принимает переменная \textit{receiver}, во время выполнения, есть поле \textit{field}, но нету метода \textit{getField()}. Тогда мы должны текущий вызов связать с получением этого поля.
    \item У типа, который принимает переменная \textit{receiver}, во время выполнения, нету поля \textit{field}, но есть метод \textit{getField()}. Тогда мы должны текущий вызов связать с вызовом этого метода.
    \item У типа, который принимает переменная \textit{receiver}, во время выполнения, есть поле \textit{field} и метод \textit{getField()}. Тогда мы должны текущий вызов связать с получением этого поля \textit{field}, потому что так происходит в языке Kotlin при статической типизации.
\end{itemize}






\subsubsection{Обзор ситуаций требующих изменения вызываемого метода}
\label{sec:methodChangeOverview}

Рассмотрим подробно ситуации в языке Kotlin, в которых у нас может возникнуть желание поменять решение о выборе метода, который мы будем вызывать.

\begin{minted}[mathescape,
               linenos,
               numbersep=5pt,
               gobble=2,
               frame=lines,
               framesep=2mm]{kotlin}
    receiver.field
\end{minted}

Предположим, во время компиляции, переменная \textit{receiver}, помечена как \textit{dynamic}. При осуществлении первого
вызова мы должны запустить \textit{процесс разрешения свойства класса или поля}.
%Предположим, во время компиляции, переменная \textit{receiver}, помечена как \textit{dynamic}. При осуществлении первого %вызова мы должны запустить \textit{процесс разрешения свойства класса или поля}, при котором мы можем попасть в одну %из трёх ситуаций:

%\begin{itemize}
    %\item У типа, который принимает переменная \textit{receiver}, во время выполнения, есть поле \textit{field}, но нету %метода \textit{getField()}. Тогда мы должны текущий вызов связать с получением этого поля.
    %\item У типа, который принимает переменная \textit{receiver}, во время выполнения, нету поля \textit{field}, но есть %метод \textit{getField()}. Тогда мы должны текущий вызов связать с вызовом этого метода.
    %\item У типа, который принимает переменная \textit{receiver}, во время выполнения, есть поле \textit{field} и метод %\textit{getField()}. Тогда мы должны текущий вызов связать с получением этого поля \textit{field}, потому что так %происходит в языке Kotlin при статической типизации.
%\end{itemize}

При повторном вызове, в зависимости от изменения типа, который принимает переменная \textit{receiver}, во время выполнения, у нас может быть две ситуации:

\begin{itemize}
    \item Тип не изменился. Тогда мы имееем право вызвать то же поле или метод, которые мы разрешили при первом вызове.
    \item Тип изменился. Тогда мы не можем точно сказать что мы должны сейчас вызвать, и мы должны снова запустить \textit{процесс разрешения поля или свойства класса}.
\end{itemize}

\begin{minted}[mathescape,
               linenos,
               numbersep=5pt,
               gobble=2,
               frame=lines,
               framesep=2mm]{kotlin}
    receiver.field = object
\end{minted}

Ситуация присваивания значения полю или вычислимому свойству разрешается аналогично предыдущему пункту, проверяя изменение типа объекта лежащего в переменной \textit{receiver}.

\begin{minted}[mathescape,
               linenos,
               numbersep=5pt,
               gobble=2,
               frame=lines,
               framesep=2mm]{kotlin}
    receiver.method(arg1, ..., argN)
\end{minted}

Предположим, во время компиляции, переменная \textit{receiver}, помечена как \textit{dynamic}. При осуществлении первого
вызова мы должны запустить \textit{процесс разрешения целевого метода}.

При повторном вызове, нам также необходимо проверить изменения типа  \textit{receiver}. Так как язык Kotlin поддерживает перегрузку методов по типам аргументов, нам также необходимо проверить изменения типов всех аргументов $arg_i$. Существует ещё одна ситуация. При первом вызове может обнаружиться, что у класса, представителем которого является \textit{receiver}, нету метода \textit{method}, но зато есть поле или свойство класса \textit{method}, по которому лежит объект, который может быть вызван. Такие объекты характеризуются тем, что у них есть как минимум один метод с именем \textit{invoke}, помеченный что он является оператором \cite{book:jemerov2017kotlininAction}. Заметим что при наличии нескольких таких методов, нам необходимо запускать процедуру определения нужной перегрузки. Таким образом, чтобы осуществить требуемый вызов, нам необходимо вызвать получение значения поля \textit{method}, и на этом значении вызывать нужный метод с учётом перегрузок. Поэтому знания того, что класс объекта лежащего в \textit{receiver} нам недостаточно. Нам необходимо ещё знать что тот объект, который лежит в поле \textit{method} или возвращается соответсвенным свойством класса, не изменился.




\subsubsection{Методы выполняющие настройку точки вызова}

Выполнение настройки точки вызова, в общем случае можно описать так:

\begin{enumerate}
\item Разрешение требуемой ссылки на метод.
\item Установка условий, при которых в будущем, необходимо будет признавать точку вызова недействительной, и запускать процесс настройки заново.
\item Установка разрешённой ссылки на метод, как целевой для текущей точки вызова.
\item Осуществление динамического вызова в первый раз.
\end{enumerate}

Пройдёмся подробнее по каждому из пунктов. Для разрешения ссылки при динамических операциях с полями или свойствами класса, достаточно запутить динамическое разрешение с запрошенным именем и текущими аругментами, используя описанные в главе \ref{realization:dynamicResolve} механизмы.

При разрешении ссылки при динамических вызовах методов, ситуацию, при которых метод с данным именем при текущих аргументах не найден, можно исправить в некоторых случаях:

\begin{enumerate}
    \item Имя вызываемого метода входит в список операторов составных арифметических присваиваний.
    \item У класса существует поле или свойство, совпадающее по имени с текущим методом, в котором лежит объект который можно вызвать.
\end{enumerate}


\begin{table}[h]
\caption{\label{tab:compoundAssignment}Соответствие операторов составного присваивания}
\begin{center}
\begin{tabular}{|c|l|l|}
\hline
Ключевой символ & Составной оператор	& Обычный аналог \\
\hline
+=  & plusAssign             & plus   \\
-=  & minusAssign            & minus  \\
*=  & timesAssign            & times  \\
/=  & divAssign              & div    \\
\%= & modAssign              & mod    \\
\%= & remAssign\footnotemark & rem\footnotemark[\value{footnote}]   \\
\hline
\end{tabular}
\end{center}
\end{table} 

\footnotetext{Начиная с Kotlin 1.1}

В языке Kotlin, если в коде программы встречается ключевой символ из таблицы \ref{tab:compoundAssignment}, то сначала осуществляется попытка найти у класса соответсвующий этому ключевому символу, составной оператор. Если у класса отсутствует требуемый составной оператор, то для осуществляется попытка выполнить текущую операцию путём использования аналога этого составного оператора. Например, выражение \mintinline{kotlin}{a += b} может быть преобразовано либо в \mintinline{kotlin}{a.plusAssign(b)}, либо в \mintinline{kotlin}{a = a.plus(b)}. 

Однако, до момента осуществления динамического вызова, мы не можем знать, есть ли у класса, который в данный момент находится в динамической переменной составной оператор присваивания, либо, есть только его аналог. В первом случае, точка вызова должна быть связана с самим составным оператором, во втором --- с его аналогом, и затем должна быть произведена операция записи результата в переменную. Чтобы отличить эти случаи, если во время выполнения был найден настоящий составной оператор, мы будем в качестве результата возвращать объект специального типа. Такой объект мы будем называть \textit{маркер выполнения операции составного присваивания}. В самом компиляторе, будет генерироваться код, который используя специальную инструкцию \textit{instanceof}, которая проверяет является ли объект представителем данного класса, выбирает необходимо ли производить присваивание.

Заметим, что целевой метод может возвращать значение типа \textit{Unit}. В главе \ref{sec:connectKotlinWithJava} мы обсуждали тонкости реализации методов с таким возвращаемым значением. Однако, при динамическом вызове, мы не можем знать что метод, который будет выбран во время выполнения, возвращает \textit{Unit}. Поэтому необходимо осуществить явный возврат значения этого типа. Поэтому, нам необходимо выбрать ссылку на такой метод, который вызывает разрешённый ранее метод, а после возвращает экземпляр класса \textit{Unit}.

Мы уже обсуждали в главе \ref{sec:methodChangeOverview}, что у нас возможна ситуация, при которой отсутствует метод с запрошенным именем, но присутствует поле или свойство класса, которое возвращает объект поддерживающий операцию вызова.
% На этапе компиляции, мы не можем знать, будет ли в объекте, который лежит в динамической переменной, 
Таким образом, нам надо разрешить у полученного объекта метод \textit{invoke}. Заметим, что в виду поддержки перегрузок методов, разрешать надо с учётом актуальных аргументов. Для обеспечения поддержки заданной функциональности, был создан специальный класс \textit{ObjectInvoker}. Мы будем связывать точку вызова, со специальной методом этого объекта --- \textit{performInvoke}. В этом объекте мы можем запомнить ссылку на метод, выполняющий роль метода чтения поля или свойства. Во время выполнения вызова, мы будем вызывать метод чтения, а после этого, на полученном объекте разрешать метод \textit{invoke}.


Ситуации, при которых необходимо признавать точку вызова не действительной, детально описаны в главе \ref{sec:methodChangeOverview}. Для обеспечения поддержки этого механизма в Java можно воспользоваться \textit{MethodHandle.guardWithTest()}. Этот метод позволяет перед обернуть текущую ссылку на метод таким образом, что перед её выполнением будет проверен заданный предикат. При не выполнении предиката, мы будем осуществлять весь процесс разрешения заново. Нам понадобятся следующие предикаты:

\begin{minted}[mathescape,
               linenos,
               numbersep=5pt,
               gobble=2,
               frame=lines,
               framesep=2mm]{kotlin}
    boolean isInstance(Class c, Object o) {
        return o != null && o.getClass() == c;
    }

    boolean isNull(Object o) {
        return o == null;
    }
\end{minted} 

В случае \textit{ObjectInvoker}, предикаты нам должны помогать только проверить изменение класса объекта, на котором производится динамический вызов. Если этот класс не изменился, мы имеем право использовать метод доступа к полю или свойству, сохранённый при разрешении прошлого вызова. Заметим, что разрешение этого метода не зависит от типов аргументов переданных в вызов. Типы аргументов будут влиять только на разрешение метода \textit{invoke} у полученного из метода доступа объекта. Сохранив последний разрешённый метод и список типов аргументов, при котором это разрешение произошло, мы имеем право повторно вызвать метод, при условии отсутствия изменения типов аргументов.

Таким образом, получив результирующую ссылку на метод, мы можем её установить для текущей точки вызова, при помощи вызова метода 	\textit{setTarget()} \cite{javadoc:MutableCallSite}. В качестве завершения настройки точки вызова, мы возвращаем значение, полученное путём вызова установленной ссылки на метод.