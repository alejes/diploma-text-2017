\section{Реализация решения}

Для осуществления поддержки динамической типизации для компилятора Kotlin в JVM, необходимо её поддержать с двух сторон:

\begin{enumerate}
    \item Требуется разработка изменений в компиляторе, которые будут в тех местах, где осуществление типизации отложено до момента выполнения, реализовать вызов динаимических инструкций.
    \item Необходимо предоставить библиотеку, которая предоставляет набор загрузочных методов, которые выполняют необходимое динаимическое связывание в требуемых случаях - при вызове методов и при чтении или записи в поля.
\end{enumerate}

\subsection{Реализация поддержки динамических вызовов на стороне компилятора}
\label{sec:compileRealization}

Благодаря тому что при компиляции Kotlin в JavaScript, уже поддерживаются динамические вызовы, первая задача решается определение того кода, который мы будем генерировать при компиляции в байт код Java. Мы это будем делать при помощи инструкции \textit{invokedynamic}.
%Рассмотрим подробнее её синтаксис.

%СИНТАКСИС.

Первым аргументом этой инструкции мы передадим идентификатор действия, согласно таблице \ref{tab:DynamicCallType}. 

\begin{table}[h]
\caption{\label{tab:DynamicCallType}Идентификаторы динамического действия}
\begin{center}
\begin{tabular}{|c|l|}
\hline
Идентификатор	& Требуемое действие \\
\hline
getField & Получение значение поля или свойства класса  \\
setField & Установка нового значения поля или свойства класса	\\
invoke   & Вызов функции или объекта умеющего обработать вызов  \\
\hline
\end{tabular}
\end{center}
\end{table} 

Вторым аргументом нам необходимо передать ожидаемый тип функции, которую мы хотим получить в результате вызова. Этот тип мы можем составить во время компиляции, путём составления \textit{дескриптора метода}, согласно правилам описанным в главе 4.3 Descriptors \cite{book:yellin1996java}. Несмотря на то, что во время компиляции мы не знаем будущие типы, которые будут лежать в \textit{dynamic}-переменных во время исполнения, мы универсально можно приравнять их к переменным типа \textit{Object}, и использовать его сигнатуру в дескрипторе.

Третим аргументом является \textit{загрузочная функция}, реализация которой будет рассмотрена в главе \ref{sec:dynamicLibrary}.

Четвёртым аргументом пойдёт имя метода или или поля, оно нам понадобится для осуществления поиска требуемого метода во время выполнения программы.

В языке Kotlin поддерживается использование аргументов по умолчанию. Это означает что части последних аргументов функции мы можем указать значение по умолчанию. Тогда мы получаем возможность опускать часть последних аргументов \cite{book:jemerov2017kotlininAction}. При вызове функции с меньшим числом аргументов, компилятор осуществит вызов специально сгенерированного для этой функции помощника, который подготовит все недостающие аргументы функции, вычислив их согласно значениям по умолчанию. После этого, помощник осуществит вызов требуемой функции, так как для этого вызова у него уже будут все аргументы.

Аргументы по умолчанию являются мощным инструментом в сочетании с другой возможностью языка --- именованные аргументы. В аргументах по умолчанию, если мы не имели возможность опускать произвольные аргументы, имеющие значение по умолчанию. Если мы опустили какой-то аргумент функции, то следующие мы тоже должны были опустить, потому что компилятор не мог понять какой именно аргумент мы хотим передать. Одним из способов решения этой проблемы являются именованные аргументы. Мы можем пометить приписать части параметров имя аргумента в вызываемой функции, в качестве которого мы хотим передать текущий параметр \cite{book:jemerov2017kotlininAction}. Для того чтобы избежать неопределённостей, все именованные аргументы должны тоже идти последними.

Заметим что если мы хотим поддержать именованные аргументы в динамическом вызове, нам необходимо сохранить все метки имён аргументов до момента разрешения динамического вызова. Для этого мы их передадим в качестве последних аргументов в \textit{invokedynamic} инструкцию. Заметим, что поскольку именованные аргументы всегда находятся последними, нам не нужно сохранять соотвествие между именами аргументов и переданными значениями, и мы их сможем однозначно восстановить во время выполнения.


\subsection{Реализация библиотеки для поддержки динамического связывания}
\label{sec:dynamicLibrary}

Рассмотрим основные компоненты библиотеки, которую нам потребуется реализовать:

\begin{itemize}
    \item Загрузочная функция.
    \item Механизм динамического разрешения перегрузок.
    \item Методы выполняющие настройку точки вызова для различных типов динамических операций.
    \item Механизм кеширующего взаимодействия с лежащими в полях или свойствах класса вызываемыми объектами.
    \item Маркер выполнения операции составного присваивания.
\end{itemize}

Детальней рассмотрим каждую из этих компонент.

\subsubsection{Загрузочная функция}

Основная задача загрузочной функции состоит в том, чтобы в зависимости от требуемого динамического действия, обеспечить вовзращение объекта, в котором лежит точка вызова, с соответствующей действию ссылкой на метод. Для этого, в качестве параметров мы получаем специальный объект типа \textit{MethodHandles.Lookup}, который будет осуществлять проверку разрешений доступа --- возможен ли из текущего места вызова, доступ к выбранному методу или полю и свойству класса. Также мы получаем все параметры, которые мы передали в \textit{invokedynamic} инструкцию при компиляции, согласно главе \ref{sec:compileRealization}.

В самой загрузочной функции, мы перебираем все типы динамических  действий согласно таблице \ref{tab:DynamicCallType}, и выбираем нужный метод-настройщик. После его установки, он будет вызван с актуальными аргументами пользовательского вызова. Заметим, что при вызове метода-настройщика, мы можем потерять знания переданные в загрузочную функцию. В данный момент мы ещё не можем осуществить поиск нужного метода или поля, потмоу что мы не знаем актуальных параметров времени выполнения. Поэтому определения целевого метода или поля и свойства класса, необходимо осуществлять в методе-настройщике. Но там нам также понадобится объект типа \textit{MethodHandles.Lookup}, для осуществления проверки корректности прав доступа. Поэтому, мы воспользуемся механизмом  \textit{MethodHandles.insertArguments} \cite{javadoc:MethodHandlesLookup}. С его помощью мы получим ссылку на метод, которому можно будет передать аргументы в соответствии с ожидаемым типом аргументом, который мы запросили при генерации \textit{invokedynamic} инструкции, который при этом в себе вызывает нашу функцию-настройщик, и передаёт в неё необходимые в дальнейшем аргументы из загрузочной функции. В дальнейшем нам понадобятся следующие объекты:
\begin{itemize}
    \item Точка вызова.
    \item Объект типа \textit{MethodHandles.Lookup}.
    \item Ожидаемый тип ссылки на метод.
    \item Имя вызываемого метода или поля и свойства класса.
    \item Именованные аргументы (только при осуществлении вызова функции).
\end{itemize}


\subsubsection{Механизм динамического разрешения перегрузок}
\label{realization:dynamicResolve}

В настоящий момент, всё разрешение методов в компиляторе языка Kotlin, при компиляции в байт код Java, происходит во время компиляции, основываясь на тех знания о типах, которые мы имеем во время компиляции. Для осуществления динамического связывания, необходимо разработать инструмент, который на основании имени функции, и всех её параметров, основываясь, на типовой информации времени выполнения, получит ссылку на метод который требуется вызвать. Данный механизм должен поддерживать выбор функции с учётом её перегрузок, он должен принимать во внимание функции с переменным числом аргументов, функции с аргументами по умолчанию, а также вызов функций с использованием именованных аргументов.

Предположим, у нас осуществляется следующий динамический вызов:

\begin{minted}[mathescape,
               linenos,
               numbersep=5pt,
               gobble=2,
               frame=lines,
               framesep=2mm]{kotlin}
    receiver.method(arg1, ..., argN)
\end{minted}

Алгоритм разрешения перегрузок можно описать следующим образом:

\begin{enumerate}
    \item Получить список всех методов, которые есть у типа, который в момент выполнения находится в переменной \textit{receiever}.
    \item Удалить все методы, имя которых не подходит.\label{itm:del1}
    \item Удалить те методы, тип которых не подходит к актуальным аргументам динамического вызова.\label{itm:del2}
    \item Если полученный набор методов пуст, то попробовать осуществить шаги \label{itm:del1}-\label{itm:del2} на наборе встроенных методов.
    \item Среди оставшихся методов выбрать наиболее специфичный, по сравнению с другими.
    \item Если наиболее специфичный метод не найден, то завершить поиск с ошибкой.
    \item Проверить согласованность с правами доступа.
    \item При необходимости учесть аргументы по умолчанию и именованные аргументы.
    \item Завершить алгоритм, вернув результирующую ссылку на метод
\end{enumerate}

Остановимся подробнее на реализации этих пунктов. Для поиска всех методов класса можно использовать механизм Java Reflection API. Однако, не все методы мы сможем найти. Как мы обсуждали в главе \ref{sec:connectKotlinWithJava}, некоторых типов языка Kotlin, не существует во время выполнения, и все они превращаются в соотвествующие им типы Java. Однако, у типов Java уже не будет всех методов, которые мы могли вызвать у аналога из Kotlin. Поэтому нам необходимо реализовать библиотеку, в которой присутствуют все недостоющие методы, и при необходимости, выполнять разрешения в пользу методов данной библиотеки.


При запросе разрешения имени поля и свойства, важным моментом является выработка осознания того, что перед нами - поле или свойство класса. Предположим динамический вызов выглядит так:

\begin{minted}[mathescape,
               linenos,
               numbersep=5pt,
               gobble=2,
               frame=lines,
               framesep=2mm]{kotlin}
    receiver.field
\end{minted}

Однако, мы точно не знаем, это поле \textit{field} класса или свойство \textit{field} класса. Если это является свойством класса, то необходимо осуществлять доступ посредством специального \textit{метода чтения}, который будет выглядеть как функция с именем \textit{getField()}. Таким образом, у нас возможна одна из трёх ситуаций, каждую из котоорых мы должны обработать:

\begin{itemize}
    \item У типа, который принимает переменная \textit{receiver}, во время выполнения, есть поле \textit{field}, но нету метода \textit{getField()}. Тогда мы должны текущий вызов связать с получением этого поля.
    \item У типа, который принимает переменная \textit{receiver}, во время выполнения, нету поля \textit{field}, но есть метод \textit{getField()}. Тогда мы должны текущий вызов связать с вызовом этого метода.
    \item У типа, который принимает переменная \textit{receiver}, во время выполнения, есть поле \textit{field} и метод \textit{getField()}. Тогда мы должны текущий вызов связать с получением этого поля \textit{field}, потому что так происходит в языке Kotlin при статической типизации.
\end{itemize}

\subsubsection{Методы выполняющие настройку точки вызова}

Выполнение настройки точки вызова, в общем случае можно описать так:

\begin{enumerate}
\item Разрешение требуемой ссылки на метод.
\item Установка условий, при которых в будущем, необходимо будет признавать точку вызова недействительной, и запускать процесс настройки заново.
\item Установка разрешённой ссылки на метод, как целевой для текущей точки вызова.
\item Осуществление динамического вызова в первый раз.
\end{enumerate}

Пройдёмся подробнее по каждому из пунктов. Для разрешения ссылки при динамических операциях с полями или свойствами класса, достаточно запутить динамическое разрешение с запрошенным именем и текущеми аругментами, используяю описанные в главе \ref{realization:dynamicResolve} механизмы.

При разрешении ссылки при динамических вызовах методов, ситуацию, при которых метод с данным именем при текущих аргументах не найден, можно исправить в некоторых случаях:

\begin{enumerate}
    \item Имя вызываемого метода входит в список операторов составных арифметических присваиваний.
    \item У класса существует поле или свойство, совпадающее по имени с текущим методом, в котором лежит объект который можно вызвать.
\end{enumerate}


\begin{table}[h]
\caption{\label{tab:compoundAssignment}Соответствие операторов составного присваивания}
\begin{center}
\begin{tabular}{|c|l|l|}
\hline
Ключевой символ & Составной оператор	& Обычный аналог \\
\hline
+=  & plusAssign             & plus   \\
-=  & minusAssign            & minus  \\
*=  & timesAssign            & times  \\
/=  & divAssign              & div    \\
\%= & modAssign              & mod    \\
\%= & remAssign\footnotemark & rem\footnotemark[\value{footnote}]   \\
\hline
\end{tabular}
\end{center}
\end{table} 

\footnotetext{Начиная с Kotlin 1.1}

В языке Kotlin, если в коде программы встречается ключевой символ из таблицы \ref{tab:compoundAssignment}, то сначала осуществляется попытка найти у класса соответсвующий этому ключевому символу, составной оператор. Если у класса отсутствует требуемый составной оператор, то для осуществляется попытка выполнить текущую операцию путём использования аналога этого составного оператора. Например, выражение \mintinline{kotlin}{a += b} может быть преобразовано либо в \mintinline{kotlin}{a.plusAssign(b)}, либо в \mintinline{kotlin}{a = a.plus(b)}. 

Однако, до момента осуществления динамического вызова, мы не можем знать, есть ли у класса, который в данный момент находится в динамической переменной составной оператор присваивания, либо, есть только его аналог. В первом случае, точка вызова должна быть связана с самим составным оператором, во втором --- с его аналогом, и затем должна быть произведена операция записи результата в переменную. Чтобы отличить эти случаи, если во время выполнения был найден настоящий составной оператор, мы будем в качестве результата возвращать объект специального типа. Такой объект мы будем называть \textit{маркер выполнения операции составного присваивания}. В самом компиляторе, будет генерироваться код, который используя специальную инструкцию \textit{instanceof}, которая проверяет является ли объект представителем данного класса, выбирает необходимо ли производить присваивание.

Мы уже обсуждали в главе \ref{sec:methodChangeOverview}, что у нас возможна ситуация, при которой у нас отсутствует метод с запрошенным именем, но присутствует поле или свойство класса, которое возвращает объект поддерживающий операцию вызова.
% На этапе компиляции, мы не можем знать, будет ли в объекте, который лежит в динамической переменной, 
Таким образом, нам надо разрешить у полученного объекта функцию \textit{invoke}. Заметим, что в виду поддержки перегрузок функций, разрешать надо с учётом актуальных аргументов. Для обеспечения поддержки заданной функциональности, был создан специальный класс \textit{ObjectInvoker}. Мы будем связывать точку вызова, со специальной функцией этого объекта --- \textit{performInvoke}. В этом объекте мы можем запомнить ссылку на метод, выполняющий роль метода чтения поля или свойства. Во время выполнения вызова, мы будем вызывать метод чтения, а после этого, на полученном объекте разрешать функцию \textit{invoke}.


Ситуации, при которых необходимо признавать точку вызова не действительной, детально описаны в главе \ref{sec:methodChangeOverview}. Для обеспечения поддержки этого механизма в Java можно воспользоваться \textit{MethodHandle.guardWithTest()}. Этот метод позволяет перед обернуть текущую ссылку на метод таким образом, что перед её выполнением будет проверен заданный предикат. При не выполнении предиката, мы будем осуществлять весь процесс разрешения заново. Нам понадобятся следующие предикаты:

\begin{minted}[mathescape,
               linenos,
               numbersep=5pt,
               gobble=2,
               frame=lines,
               framesep=2mm]{kotlin}
    boolean isInstance(Class c, Object o) {
        return o != null && o.getClass() == c;
    }

    boolean isNull(Object o) {
        return o == null;
    }
\end{minted} 

В случае \textit{ObjectInvoker}, предикаты нам должны помогать только проверить изменение класса объекта, на котором производится динамический вызов. Если этот класс не изменился, мы имеем право использовать метод доступа к полю или свойству, сохранённый при разрешении прошлого вызова. Заметим, что разрешение этого метода не зависит от типов аргументов переданных в вызов. Типы аргументов будут влиять только на разрешение метода \textit{invoke} у полученного из метода доступа объекта. Сохранив последний разрешённый метод и список типов аргументов, при котором это разрешение произошло, мы имеем право повторно вызвать метод, при условии отсутствия изменения типов аргументов.

Таким образом, получив результирующую ссылку на метод, мы можем её установить для текущей точки вызова, при помощи вызова метода 	\textit{setTarget()} \cite{javadoc:MutableCallSite}. В качестве завершения настройки точки вызова, мы возвращаем значение, полученное путём вызова установленной ссылки на метод.