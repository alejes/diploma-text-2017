\section{Реализация решения}

Для осуществления поддержки динамической типизации для компилятора Kotlin в JVM, необходимо её поддержать с двух сторон:

\begin{enumerate}
    \item Требуется разработка изменений в компиляторе, которые будут в тех местах, где осуществление типизации отложено до момента выполнения, реализовать вызов динаимических инструкций.
    \item Необходимо предоставить библиотеку, которая предоставляет набор загрузочных функций, которые выполняют необходимое динаимическое связывание в требуемых случаях - при вызове методов и при чтении или записи в поля.
\end{enumerate}

\subsection{Реализация поддержки динамических вызовов на стороне компилятора}

Благодаря тому что при компиляции Kotlin в JavaScript, уже поддерживаются динамические вызовы, первая задача решается определение того кода, который мы будем генерировать при компиляции в байт код Java. Мы это будем делать при помощи инструкции \textit{invokedynamic}.
Рассмотрим подробнее её синтаксис.

СИНТАКСИС.

Первым аргументом этой инструкции мы передадим идентификатор действия, согласно таблице \ref{tab:DynamicCallType}. 

\begin{table}[h]
\caption{\label{tab:DynamicCallType}Идентификаторы динамического действия}
\begin{center}
\begin{tabular}{|c|l|}
\hline
Идентификатор	& Требуемое действие \\
\hline
getField & Получение значение поля или свойства класса \\
setField & Установка нового значения поля или свойства класса	\\
invoke &	Вызов функции или объекта умеющего обработать вызов\\
\hline
\end{tabular}
\end{center}
\end{table} 

Вторым аргументом нам необходимо передать ожидаемый тип функции, которую мы хотим получить в результате вызова. Этот тип мы можем составить во время компиляции, путём составления \textit{дескриптора метода}, согласно правилам описанным в главе 4.3 Descriptors \cite{book:yellin1996java}. Несмотря на то, что во время компиляции мы не знаем будущие типы, которые будут лежать в \textit{dynamic}-переменных во время исполнения, мы универсально можно приравнять их к переменным типа \textit{Object}, и использовать его сигнатуру в дескрипторе.

Третим аргументом является \textit{загрузочная функция}, реализация которой будет рассмотрена в главе \ref{sec:dynamicLibrary}.

Четвёртым аргументом пойдёт имя метода или или поля, оно нам понадобится для осуществления поиска требуемого метода во время выполнения программы.

В языке Kotlin поддерживается использование аргументов по умолчанию. Это означает что части последних аргументов функции мы можем указать значение по умолчанию. Тогда мы получаем возможность опускать часть последних аргументов \cite{book:jemerov2017kotlininAction}. При вызове функции с меньшим числом аргументов, компилятор осуществит вызов специально сгенерированного для этой функции помощника, который подготовит все недостающие аргументы функции, вычислив их согласно значениям по умолчанию. После этого, помощник осуществит вызов требуемой функции, так как для этого вызова у него уже будут все аргументы.

Аргументы по умолчанию являются мощным инструментом в сочетании с другой возможностью языка --- именованные аргументы. В аргументах по умолчанию, если мы не имели возможность опускать произвольные аргументы, имеющие значение по умолчанию. Если мы опустили какой-то аргумент функции, то следующие мы тоже должны были опустить, потому что компилятор не мог понять какой именно аргумент мы хотим передать. Одним из способов решения этой проблемы являются именованные аргументы. Мы можем пометить приписать части параметров имя аргумента в вызываемой функции, в качестве которого мы хотим передать текущий параметр \cite{book:jemerov2017kotlininAction}. Для того чтобы избежать неопределённостей, все именованные аргументы должны тоже идти последними.

Заметим что если мы хотим поддержать именованные аргументы в динамическом вызове, нам необходимо сохранить все метки имён аргументов до момента разрешения динамического вызова. Для этого мы их передадим в качестве последних аргументов в \textit{invokedynamic} инструкцию. Заметим, что поскольку именованные аргументы всегда находятся последними, нам не нужно сохранять соотвествие между именами аргументов и переданными значениями, и мы их сможем однозначно восстановить во время выполнения.


\subsection{Реализация библиотеки для поддержки динамического связывания}
\label{sec:dynamicLibrary}