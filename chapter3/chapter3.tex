\section{Реализация решения}

Для осуществления поддержки динамической типизации для компилятора Kotlin в JVM, необходимо её поддержать с двух сторон:

\begin{enumerate}
    \item Требуется разработка изменений в компиляторе, которые будут в тех местах, где осуществление типизации отложено до момента выполнения, реализовать вызов динаимических инструкций.
    \item Необходимо предоставить библиотеку, которая предоставляет набор загрузочных функций, которые выполняют необходимое динаимическое связывание в требуемых случаях - при вызове методов и при чтении или записи в поля.
\end{enumerate}

\subsection{Реализация поддержки динамических вызовов на стороне компилятора}
\label{sec:compileRealization}

Благодаря тому что при компиляции Kotlin в JavaScript, уже поддерживаются динамические вызовы, первая задача решается определение того кода, который мы будем генерировать при компиляции в байт код Java. Мы это будем делать при помощи инструкции \textit{invokedynamic}.
Рассмотрим подробнее её синтаксис.

СИНТАКСИС.

Первым аргументом этой инструкции мы передадим идентификатор действия, согласно таблице \ref{tab:DynamicCallType}. 

\begin{table}[h]
\caption{\label{tab:DynamicCallType}Идентификаторы динамического действия}
\begin{center}
\begin{tabular}{|c|l|}
\hline
Идентификатор	& Требуемое действие \\
\hline
getField & Получение значение поля или свойства класса  \\
setField & Установка нового значения поля или свойства класса	\\
invoke   & Вызов функции или объекта умеющего обработать вызов  \\
\hline
\end{tabular}
\end{center}
\end{table} 

Вторым аргументом нам необходимо передать ожидаемый тип функции, которую мы хотим получить в результате вызова. Этот тип мы можем составить во время компиляции, путём составления \textit{дескриптора метода}, согласно правилам описанным в главе 4.3 Descriptors \cite{book:yellin1996java}. Несмотря на то, что во время компиляции мы не знаем будущие типы, которые будут лежать в \textit{dynamic}-переменных во время исполнения, мы универсально можно приравнять их к переменным типа \textit{Object}, и использовать его сигнатуру в дескрипторе.

Третим аргументом является \textit{загрузочная функция}, реализация которой будет рассмотрена в главе \ref{sec:dynamicLibrary}.

Четвёртым аргументом пойдёт имя метода или или поля, оно нам понадобится для осуществления поиска требуемого метода во время выполнения программы.

В языке Kotlin поддерживается использование аргументов по умолчанию. Это означает что части последних аргументов функции мы можем указать значение по умолчанию. Тогда мы получаем возможность опускать часть последних аргументов \cite{book:jemerov2017kotlininAction}. При вызове функции с меньшим числом аргументов, компилятор осуществит вызов специально сгенерированного для этой функции помощника, который подготовит все недостающие аргументы функции, вычислив их согласно значениям по умолчанию. После этого, помощник осуществит вызов требуемой функции, так как для этого вызова у него уже будут все аргументы.

Аргументы по умолчанию являются мощным инструментом в сочетании с другой возможностью языка --- именованные аргументы. В аргументах по умолчанию, если мы не имели возможность опускать произвольные аргументы, имеющие значение по умолчанию. Если мы опустили какой-то аргумент функции, то следующие мы тоже должны были опустить, потому что компилятор не мог понять какой именно аргумент мы хотим передать. Одним из способов решения этой проблемы являются именованные аргументы. Мы можем пометить приписать части параметров имя аргумента в вызываемой функции, в качестве которого мы хотим передать текущий параметр \cite{book:jemerov2017kotlininAction}. Для того чтобы избежать неопределённостей, все именованные аргументы должны тоже идти последними.

Заметим что если мы хотим поддержать именованные аргументы в динамическом вызове, нам необходимо сохранить все метки имён аргументов до момента разрешения динамического вызова. Для этого мы их передадим в качестве последних аргументов в \textit{invokedynamic} инструкцию. Заметим, что поскольку именованные аргументы всегда находятся последними, нам не нужно сохранять соотвествие между именами аргументов и переданными значениями, и мы их сможем однозначно восстановить во время выполнения.


\subsection{Реализация библиотеки для поддержки динамического связывания}
\label{sec:dynamicLibrary}

Рассмотрим основные компоненты библиотеки:

\begin{itemize}
    \item Загрузочная функция.
    \item Методы выполняющие настройку точки вызова для различных типов динамических операций.
    \item Механизм динамического разрешения перегрузок.
    \item Механизм кеширующего взаимодействия с лежащими в полях или свойствах класса вызываемыми объектами.
    \item Маркер выполнения операции составного присваивания.
\end{itemize}

Детальней рассмотрим каждую из этих компонент.

\subsubsection{Загрузочная функция}

Основная задача загрузочной функции состоит в том, чтобы в зависимости от требуемого динамического действия, обеспечить вовзращение объекта, в котором лежит точка вызова, с соответствующей действию ссылкой на метод. Для этого, в качестве параметров мы получаем специальный объект типа \textit{MethodHandles.Lookup}, который будет осуществлять проверку разрешений доступа --- возможен ли из текущего места вызова, доступ к выбранному методу или полю и свойству класса. Также мы получаем все параметры, которые мы передали в \textit{invokedynamic} инструкцию при компиляции, согласно главе \ref{sec:compileRealization}.

В самой загрузочной функции, мы перебираем все типы динамических  действий согласно таблице \ref{tab:DynamicCallType}, и выбираем нужный метод-настройщик. После его установки, он будет вызван с актуальными аргументами пользовательского вызова. Заметим, что при вызове метода-настройщика, мы можем потерять знания переданные в загрузочную функцию. В данный момент мы ещё не можем осуществить поиск нужного метода или поля, потмоу что мы не знаем актуальных параметров времени выполнения. Поэтому определения целевого метода или поля и свойства класса, необходимо осуществлять в методе-настройщике. Но там нам также понадобится объект типа \textit{MethodHandles.Lookup}, для осуществления проверки корректности прав доступа. Поэтому, мы воспользуемся механизмом  \textit{MethodHandles.insertArguments} \ref{javadoc:MethodHandlesLookup}. С его помощью мы получим ссылку на метод, которому можно будет передать аргументы в соответствии с ожидаемым типом аргументом, который мы запросили при генерации \textit{invokedynamic} инструкции, который при этом в себе вызывает нашу функцию-настройщик, и передаёт в неё необходимые в дальнейшем аргументы из загрузочной функции. В дальнейшем нам понадобятся следующие объекты:
\begin{itemize}
    \item Точка вызова.
    \item Объект типа \textit{MethodHandles.Lookup}.
    \item Ожидаемый тип ссылки на метод.
    \item Имя вызываемого метода или поля и свойства класса.
    \item Именованные аргументы (только при осуществлении вызова функции).
\end{itemize}
