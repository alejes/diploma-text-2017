\section{Подход к решению задачи}

Для поддержки динамических языков на платформе JVM, в JSR 292, была предложена новая байткод инструкция \textit{invokedynamic}, которая поддерживает эффективное и гибкое решение выполнения вызовов, в условиях отсутствия статической информации о типах \cite{java:JSR292rosejsr}.

Инструкция \textit{invokedynamic} осуществляет вызов метода, на который ссылается специальный объект, называемый точкой вызова (call site). Этот объект получается путём вызова специальной загрузочной функции (bootstrap method), ассоциированной с каждой \textit{invokedynamic} инструкцией \cite{book:yellin1996java}. Путём создания специального алгоритма поведения загрузочной функции, у нас появляется возможность, во время выполнения программы, подстраиваясь под актуальную типовую информацию, производить вызов нужных методов.

\subsection{Обзор ситуаций требующих изменения вызываемого метода}

Рассмотрим подробно ситуации в языке Kotlin, в которых у нас может возникнуть желание поменять решение о выборе метода, который мы будем вызывать.

\begin{minted}[mathescape,
               linenos,
               numbersep=5pt,
               gobble=2,
               frame=lines,
               framesep=2mm]{kotlin}
    receiver.field
\end{minted}

Предположим, во время компиляции, переменная \textit{receiver}, помечена как \textit{dynamic}. При осуществлении первого
вызова мы должны запустить \textit{процесс разрешения свойства класса или поля}.
%Предположим, во время компиляции, переменная \textit{receiver}, помечена как \textit{dynamic}. При осуществлении первого %вызова мы должны запустить \textit{процесс разрешения свойства класса или поля}, при котором мы можем попасть в одну %из трёх ситуаций:

%\begin{itemize}
    %\item У типа, который принимает переменная \textit{receiver}, во время выполнения, есть поле \textit{field}, но нету %метода \textit{getField()}. Тогда мы должны текущий вызов связать с получением этого поля.
    %\item У типа, который принимает переменная \textit{receiver}, во время выполнения, нету поля \textit{field}, но есть %метод \textit{getField()}. Тогда мы должны текущий вызов связать с вызовом этого метода.
    %\item У типа, который принимает переменная \textit{receiver}, во время выполнения, есть поле \textit{field} и метод %\textit{getField()}. Тогда мы должны текущий вызов связать с получением этого поля \textit{field}, потому что так %происходит в языке Kotlin при статической типизации.
%\end{itemize}

При повторном вызове, в зависимости от изменения типа, который принимает переменная \textit{receiver}, во время выполнения, у нас может быть две ситуации:

\begin{itemize}
    \item Тип не изменился. Тогда мы имееем право вызвать то же поле или метод, которые мы разрешили при первом вызове.
    \item Тип изменился. Тогда мы не можем точно сказать что мы должны сейчас вызвать, и мы должны снова запустить \textit{процесс разрешения поля или свойства класса}.
\end{itemize}

\begin{minted}[mathescape,
               linenos,
               numbersep=5pt,
               gobble=2,
               frame=lines,
               framesep=2mm]{kotlin}
    receiver.field = object
\end{minted}

Ситуация присваивания значения полю или вычислимому свойству разрешается аналогично предыдущему пункту, проверяя изменение типа объекта лежащего в переменной \textit{receiver}.

\begin{minted}[mathescape,
               linenos,
               numbersep=5pt,
               gobble=2,
               frame=lines,
               framesep=2mm]{kotlin}
    receiver.method(arg1, ..., argN)
\end{minted}

Предположим, во время компиляции, переменная \textit{receiver}, помечена как \textit{dynamic}. При осуществлении первого
вызова мы должны запустить \textit{процесс разрешения целевого метода}.

При повторном вызове, нам также необходимо проверить изменения типа  \textit{receiver}. Так как язык Kotlin поддерживает перегрузку функций по типам аргументов, нам также необходимо проверить изменения типов всех аргументов $arg_i$. Существует ещё одна ситуация. При первом вызове может обнаружиться, что у класса, представителем которого является \textit{receiver}, нету метода \textit{method}, но зато есть поле или свойство класса \textit{method}, по которому лежит объект, который может быть вызван. Такие объекты характеризуются тем, что у них есть как минимум одна функция с именем \textit{invoke}, помеченная что она является оператором \cite{book:jemerov2017kotlininAction}. Заметим что при наличии нескольких таких функций, нам необходимо запускать процедуру определения нужной перегрузки. Таким образом, чтобы осуществить требуемый вызов, нам необходимо вызвать получение значения поля \textit{method}, и на этом значении вызывать нужный метод с учётом перегрузок. Поэтому знания того, что класс объекта лежащего в \textit{receiver} нам недостаточно. Нам необходимо ещё знать что тот объект, который лежит в поле \textit{method} или возвращается соответсвенным свойством класса, не изменился.



\subsection{Разрешение перегрузок}

Заметим, что используя только знания о типах, которые мы получаем из самих объектов во время исполнения, мы не сможем добиться такого же разрешения перегрузок, как во время компиляции. Это можно проиллюстрировать следующим примером на языке C{\#}.

\begin{minted}[mathescape,
               linenos,
               numbersep=5pt,
               gobble=2,
               frame=lines,
               framesep=2mm]{csharp}
    public class Base {};
    public class Derived : Base {};
    
    public class A {
        public String method1(Base b) {
            return "Base";
        }
        public String method1(Derived b) {
            return "Derived";
        }
    }
\end{minted}

Если мы попробуем вызвать метод \textit{method1} класса \textit{A}, передав ему переменную  \mintinline{csharp}{Base b = new Derived()}, то мы получим в результате строку \textit{Base}. Потому что выбор будет происходить согласно статическим типам. Рассмотрим динамический случай \mintinline{csharp}{dynamic b = (Base) new Derived()}.
Без дополнительного хранения памяти о статических типах, мы не можем узнать во время исполнения статический тип b. Поэтому при передаче b в метод \textit{method1}, мы получим строку \textit{Derived}.

Также заметим, что коль скоро, выбор необходимой перегрузки должен происходить во время исполнения, становится критичен вопрос производительности нашего решения.

\subsubsection{Подход Groovy}

Алгоритм используемый для разрешения перегрузок в Groovy, можно описать следующими словами \cite{groovy:selectingOverloadsAtRuntime}.

\begin{enumerate}
    \item Создать список всех методов с подходящих именем.
    \item Удалить методы, которые не подходят к текущему вызову.
    \item Если текущий список содержит ровно один элемент, то выбираем его и завершаем процесс поиска перегрузки.
    \item Для всех методов считаем метрику \textit{расстояние между методами}, вычисленной между типами аргументов каждого метода и реальными аргументами переданными в него.
    \item Если есть метод, на котором достигается строгий минимум метрики, то выбираем этот метод и завершаем процесс поиска перегрузки.
    \item Завершаем процесс выбора перегрузки с неудачей.
\end{enumerate}

Для рассчёта метрики \textit{расстояние между методами}, мы можем воспользоваться следующим алгоритмом:
\begin{enumerate}
    \item Для произвольного аргумента метода, который является кандидатом на разрешение перегрузки, считаем расстояние в иерархии наследования между этим типом, и типом времени исполнения параметра, переданного в этот аргумент.
    \item Метрикой для конкретного метода-кандидата является сумма метрик посчитанных для всех его аргументов, согласно правилу описанному на первом шаге.
\end{enumerate}


\subsubsection{Подход С{\#}}

В C{\#}, при разрешении перегрузок, методы-кандидаты выбираются из следующих наборов \cite{csharp:languageSpecification}:

\begin{itemize}
    \item Вызов именованного метода, посредством использования вызываемого выражения.
    \item Вызов именованного конструктора, посредством использования вызываемого выражения создающего нвоый объект.
    \item Вызов метода доступа по индексу.
    \item Вызов предопределённого или пользовательского оператора, участвовавшего в выражении.
\end{itemize}

Каждый из вышеперечисленных наборов задают множество кандидатов. Рассмотрев объединение этих множеств, очищенное от функций неподходящих по имени или с неподходящим набором аргументов, можно определить лучшую функцию, согласно следующим правилам:

\begin{itemize}
    \item Если целевое множество содержит ровно одну функцию, то она признаётся лучшей.
    \item В противном случае, лучшей функцией считается та, которая лучше всех остальных функций, с учётом их списков аргументов. Целевая функция определеяется путём её сравнивания со всеми другими кандидатами \textit{специальным предикатом}, который должен показать истину при всех сравнениях.
    \item Если мы не смогли успешно определить лучшую функцию, то мы считаем что текущий выбор является неоднозначным, и мы продуцируем ошибку времени связывания.
\end{itemize}

Определение лучшего метода довольно объёмно, поэтому желающие могут ознакомиться в главе 7.5.3.2 Better function member \cite{csharp:languageSpecification}.