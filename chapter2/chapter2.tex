\section{Подход к решению задачи}

%ПЕРЕМЕСТИТЬ В ОБЗОР ЛИТЕРАТУРЫ, В КОНЕЦ, ОПИСАТЬ ПРО ДРКГИЕ ИНСТРУКЦИИ ВЫЗОВА.
%В этом разделе мы рассмотрим ситуации, в которых проявляется [ПЕРЕПИШИ]

%Прежде чем

В этом разделе, мы определим спецификацию, согласно которой будет реализована работа с динамическими переменными.  Одним из важных моментов этой спецификации является разрешение перегрузок методов. Перегрузка методов --- возможность определить несколько методов с одинаковым именем, но с разным количеством или разными типами аргументов. 
Заметим, что используя только знания о типах, которые мы получаем из самих объектов во время исполнения программы, мы не сможем добиться такого же разрешения перегрузок, как во время компиляции. Это можно проиллюстрировать следующим примером на языке C{\#}:

\begin{minted}[mathescape,
               linenos,
               numbersep=5pt,
               gobble=2,
               frame=lines,
               framesep=2mm]{csharp}
    public class Base {};
    public class Derived : Base {};
    
    public class A {
        public String method1(Base b) {
            return "Base";
        }
        public String method1(Derived b) {
            return "Derived";
        }
    }
\end{minted}

Если мы попробуем вызвать метод \textit{method1} класса \textit{A}, передав ему переменную  \mintinline{csharp}{Base b = new Derived()}, то мы получим в результате строку \textit{Base}. Потому что выбор метода будет происходить согласно статическим типам. Рассмотрим динамический случай \mintinline{csharp}{dynamic b = (Base) new Derived()}.
Без дополнительного хранения памяти о статических типах, мы не сможем узнать во время исполнения статический тип b. Поэтому выбор метода будет происходить согласно типам времени исполнения, и при передаче b в метод \textit{method1} мы получим строку \textit{Derived}.

Также заметим, что коль скоро, выбор подходящей перегрузки должен происходить во время исполнения, становится критичен вопрос производительности нашего решения.

Перед определением спецификации, мы посмотрим семантику динамических операций в языках Groovy и С\#. На основание её анализа, мы попробуем сформировать правила динамического поведения в языке Kotlin.


\subsection{Динамическое поведение Groovy}

Язык Groovy изначально динамический. Рассмотрим основные моменты, возникающие при взаимодействии статического кода с динамическим. При присваивании динамической переменной в статически типизированную, во время выполнения происходит попытка приведения типа. В случае её неуспешности, мы получим исключение \textit{GroovyCastException}. В языке Groovy существуют неявные приведения следующих типов:

\begin{itemize}
\item При присваивании различных типов в переменную типа \textit{String}, у этого типа неявно вызывается метод \textit{toString}. 
\item При присваивании в \textit{Boolean} или \textit{boolean} значения другого типа, происходят преобразования согласно конвенции \textit{Groovy Truth} \cite{groovy:groovyTruth}.
\item При присваивании значения типа \textit{String} в переменную типа \textit{Class}, происходит попытка поиска класса с соответствующим именем. 
\item Происходит автоматическое преобразование списков в массивы.
\item Происходит авто упаковка и распаковка\footnotemark.
\item Происходит автоматическое преобразование замыканий в классы с единственным абстрактным методом.
\item Классы могут неявно преобразовываться в их родителей или в реализуемые ими интерфейсы.
\item Выполняются некоторые преобразования между численными типами \cite{groovy:semanticTypeCheckingAssignments}. 
\end{itemize}
При присваивании статически типизированной переменной в динамическую, никаких дополнительных проверок и преобразований не происходит.
Поиск нужной перегрузки метода осуществляется в момент выполнения, как в случае когда метод вызывается на динамической переменной, так и в случае когда динамическая переменная участвует среди аргументов.

\footnotetext{Про упаковку и распаковку будет рассказано в главе \ref{sec:connectKotlinWithJava}.}

%\subsection{Динамическое разрешение перегрузок}


%Прежде чем определить правила динамического разрешения перегрузок в языке Kotlin, рассмотрим как это происходит в других языках.

%\subsubsection{Подход Groovy}

Алгоритм используемый для разрешения перегрузок в Groovy, согласно \cite{groovy:selectingOverloadsAtRuntime}, можно описать следующими словами:

\begin{enumerate}
    \item Создать список всех методов с подходящих именем.
    \item Удалить методы, параметры которых не подходят к текущему вызову.
    \item Если текущий список содержит ровно один элемент, то выбираем его и завершаем процесс поиска перегрузки.
    \item Для всех методов считаем метрику \textit{расстояние между методами}, вычисленную между типами аргументов каждого метода и реальными аргументами переданными в него.
    \item Если есть метод, на котором достигается строгий минимум метрики, то выбираем этот метод и завершаем процесс поиска перегрузки.
    \item Завершаем процесс выбора перегрузки с неудачей.
\end{enumerate}

Для вычисления метрики \textit{расстояние между методами}, можно воспользоваться следующим алгоритмом:
\begin{enumerate}
    \item Для произвольного аргумента метода, который является кандидатом на разрешение перегрузки, считаем расстояние в иерархии наследования между этим типом, и типом времени исполнения параметра, переданного в этот аргумент.
    \item Метрикой для конкретного метода-кандидата является сумма метрик посчитанных для всех его аргументов, согласно правилу описанному на первом шаге.
\end{enumerate}

\subsection{Динамическое поведение С{\#}}
\label{sec:dynamicBehaviorSCharp}

Язык C\# изначально статически типизированный. При присваивании статически типизированной переменной в динамическую переменную не происходит никаких проверок. При обратном присваивании, возможны два случая:
\begin{itemize}
    \item При присваивании используется  явное преобразование динамической переменной. Тогда во время компиляции происходит статическая проверка возможности присваивания двух статических типов. При её неуспешности, мы получаем ошибку времени компиляции. Далее, во время выполнения программы происходит попытка выполнить неявное преобразование. Если оно было не успешно, происходит ошибка во время выполнения. 
    \item Если явное преобразование отсутствует, то во время выполнения программы происходит поиск неявного преобразования из типа который лежит в динамической переменной в статический тип \cite{csharp:languageSpecification}. При отсутствии неявного преобразования, мы получаем ошибку во время выполнения. 
\end{itemize}



При перегрузке методов мы обычно не знаем множество кандидатов до момента выполнения. Однако, есть набор случаев, при котором он известен:
\begin{itemize}
    \item Статический вызов с динамическими аргументами.
    \item Вызов методов на статически типизированной переменной. 
    \item Вызов по индексу, осуществлённый на статически типизированной переменной. 
    \item Вызов конструктора с динамическими аргументами. 
\end{itemize}
Во всех перечисленных случаях, во время компиляции происходит частичная проверка, игнорирующая динамически типизированный код. 

В C{\#}, при разрешении перегрузок, методы-кандидаты выбираются из следующих наборов \cite{csharp:languageSpecification}:

\begin{itemize}
    \item Вызов именованного метода, посредством использования вызываемого выражения.
    \item Вызов именованного конструктора, посредством использования вызываемого выражения создающего новый объект.
    \item Вызов метода доступа по индексу.
    \item Вызов предопределённого или пользовательского оператора, участвовавшего в выражении.
\end{itemize}

Каждый из вышеперечисленных наборов задаёт множество кандидатов. Рассмотрев объединение этих множеств, очищенное от методов неподходящих по имени или по набору аргументов, можно определить лучший метод, согласно следующим правилам:

\begin{itemize}
    \item Если целевое множество содержит ровно один метод, то он признаётся лучшим.
    \item В противном случае, лучшим методом считается тот, который лучше всех остальных методов, с учётом их списков аргументов. Целевой метод определяется путём его сравнивания со всеми другими кандидатами \textit{специальным предикатом}, который должен показать истину при всех сравнениях.
    \item Если мы не смогли успешно определить лучший метод, то мы считаем что текущий выбор является неоднозначным, и мы продуцируем ошибку времени выполнения.
\end{itemize}

Определение лучшего метода довольно объёмно, желающие могут ознакомиться с ним в главе 7.5.3.2 Better function member \cite{csharp:languageSpecification}.


\subsection{Предложенное взаимодействие с динамическим кодом в Kotlin}

Принимая во внимание обзор особенностей разрешения перегрузок в других языках, сформируем правила, согласно которым, должны происходить операции с участием динамических переменных в языке Kotlin. При разработке правил операций мы будем стараться учитывать следующие критерии:

\begin{itemize}
    \item Предсказуемость динамического поведения.
    \item Схожесть динамического поведения со статическим.
\end{itemize}

Составим список операций с участием динамического кода. Для каждой операции выработаем правила, работу согласно которым мы будем ожидать от языка Kotlin.

\begin{itemize}
    \item Присваивание в динамическую переменную.
    \item Присваивание динамической переменной в типизированную.
    \item Вызов метода на динамической переменной.
    \item Вызов метода на типизированной переменной.
    \item Запрос поля у динамической переменной.
    \item Запрос динамического поля у не динамической переменной.
\end{itemize}

При присваивании в динамическую переменную, мы будем ожидать точно такое же поведение, как при присваивании в тип \textit{Any?}.

При присваивании динамической переменной в типизированную, мы хотим ожидать такое же поведение как при привидении \textit{Any?} к этому типу --- во время выполнения должна произойти проверка, что согласно иерархии наследования, данное присваивание действительно может произойти.%, принимая во внимание иерархию наследования.

При вызове метода на динамической переменной, мы хотим поведение, которое похоже на статическое поведение языка Kotlin.
Поэтому, мы будем хотеть, чтобы среди всех методов, которые можно вызвать на лежащем в динамической переменной типе, выбрался такой, что:
\begin{enumerate}
    \item Его имя совпадает с динамически вызванным методом. \label{tbl:better1}
    \item К его аргументам подходят аргументы времени выполнения у динамического метода. \label{tbl:better2}
    \item Он является \textit{более специфичный}, чем все другие методы, которые удовлетворяют пунктам \ref{tbl:better1}-\ref{tbl:better2}.
\end{enumerate}

Если у нас не получилось выбрать метод согласно вышеуказанным правилам, мы хотим получить исключение времени исполнения.

Про два типа $\phi$ и $\psi$, будем говорить:
\begin{itemize}
    \item Что $\phi$ и $\psi$ \textit{эквивалентные типы}, если они в точности совпадают.
    \item Что $\phi$ и $\psi$ \textit{похожие типы}, если один из них, является упакованной\footnotemark       версией другого.
    \item Что $\phi$ \textit{лучший тип} чем  $\psi$, если $\phi$ реализует интерфейс $\psi$, или является его потомком.
    \item Во всех других случаях, будем говорить, что $\phi$ \textit{худший тип}, чем $\psi$.
\end{itemize}

\footnotetext{Про упаковку будет рассказано в главе \ref{sec:connectKotlinWithJava}.}

Для сравнения специфичности методов $f(\{a_i\})$ и $g(\{b_i\})$, можно использовать следующий алгоритм:

\begin{enumerate}
    \item Если $f$ совпадает с $g$, то он \textit{более специфичный} чем $g$.
    \item Если $f$ является методом-помощником, то он \textit{более специфичный} чем $g$.
    \item Если $g$ является методом-помощником, то он \textit{менее специфичный} чем $f$.
    \item Если возвращаемый тип $f$ \textit{лучше}, чем тип \textit{g}, то $f$ \textit{более специфичный}.
    \item Если возвращаемый тип $f$ \textit{хуже}, чем тип \textit{g}, то $f$ \textit{менее специфичный}.
    \item Если у $f$ существует такой индекс \textit{i}, что \textit{i}-ый параметр $f$ \textit{хуже} чем \textit{i}-ый параметр \textit{g}, то $f$ \textit{менее специфичный} чем $g$.
    \item Если у $f$ существует такой индекс \textit{i}, что \textit{i}-ый параметр $f$ \textit{лучше} чем \textit{i}-ый параметр \textit{g}, то $f$ \textit{более специфичный} чем $g$.
    \item Если $g$ является методом с переменным числом аргументов, а $f$ --- нет, то $f$ \textit{более специфичный}.
    \item Во всех остальных случаях, $f$ \textit{менее специфичный}.
\end{enumerate}

При вызове метода на типизированной переменной, мы хотим запускать разрешение перегрузки во время компиляции, считая что \textit{dynamic} это наименее специфичный тип из всех. Стоит отметить, что это может вызывать некоторые не интуитивные ситуации, например если у нас есть две перегрузки:

\begin{minted}[mathescape,
               linenos,
               numbersep=5pt,
               gobble=2,
               frame=lines,
               framesep=2mm]{kotlin}
    fun foo(s: String)
    fun foo(d: dynamic)
\end{minted} 

То следующие вызовы будут разрешены в пользу перегрузки \mintinline{kotlin}{foo(String)}:

\begin{minted}[mathescape,
               linenos,
               numbersep=5pt,
               gobble=2,
               frame=lines,
               framesep=2mm]{kotlin}
    foo("")
    foo(dyn) // dyn: dynamic
\end{minted} 

С другой стороны, вызов \mintinline{kotlin}{foo(1)}, будет разрешён в пользу \mintinline{kotlin}{foo(dynamic)}, потому что он не подходит к никаким другим перегрузкам.

При запросе поля у динамической переменной, мы хотим следующее поведение:

\begin{itemize}
    \item Если у класса объекта, который в данный момент находится в динамической переменной, существует поле с запрошенным именем, мы хотим получить значение этого поля на текущем объекте.
    \item В противном случае, если у класса объекта, который в данный момент находится в динамической переменной, существует метод чтения с запрошенным именем, мы хотим получить результат его работы на текущем объекте.
    \item В противном случае, мы хотим получить исключение времени выполнения.
\end{itemize}

При запросе динамического поля у типизированной переменной, мы хотим такое же поведение, как при запросе обычного поля класса.