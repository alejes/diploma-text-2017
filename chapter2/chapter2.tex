\section{Подход к решению задачи}

%ПЕРЕМЕСТИТЬ В ОБЗОР ЛИТЕРАТУРЫ, В КОНЕЦ, ОПИСАТЬ ПРО ДРКГИЕ ИНСТРУКЦИИ ВЫЗОВА.
%В этом разделе мы рассмотрим ситуации, в которых проявляется [ПЕРЕПИШИ]

%Прежде чем

В этом разделе, мы определим спецификацию, согласно которой будет реализована работа с динамическими переменными.  Одним из важных моментов этой спецификации является разрешение перегрузок. Перегрузка методов --- возможность определить несколько методов с одинаковым именем, но с разным количеством или разными типами аргументов.


\subsection{Динамическое разрешение перегрузок}

Заметим, что используя только знания о типах, которые мы получаем из самих объектов во время исполнения, мы не сможем добиться такого же разрешения перегрузок, как во время компиляции. Это можно проиллюстрировать следующим примером на языке C{\#}.

\begin{minted}[mathescape,
               linenos,
               numbersep=5pt,
               gobble=2,
               frame=lines,
               framesep=2mm]{csharp}
    public class Base {};
    public class Derived : Base {};
    
    public class A {
        public String method1(Base b) {
            return "Base";
        }
        public String method1(Derived b) {
            return "Derived";
        }
    }
\end{minted}

Если мы попробуем вызвать метод \textit{method1} класса \textit{A}, передав ему переменную  \mintinline{csharp}{Base b = new Derived()}, то мы получим в результате строку \textit{Base}. Потому что выбор будет происходить согласно статическим типам. Рассмотрим динамический случай \mintinline{csharp}{dynamic b = (Base) new Derived()}.
Без дополнительного хранения памяти о статических типах, мы не можем узнать во время исполнения статический тип b. Поэтому при передаче b в метод \textit{method1}, мы получим строку \textit{Derived}.

Также заметим, что коль скоро, выбор необходимой перегрузки должен происходить во время исполнения, становится критичен вопрос производительности нашего решения.

Прежде чем определить правила динамического разрешения перегрузок в языке Kotlin, рассмотрим как это происходит в других языках.

\subsubsection{Подход Groovy}

Алгоритм используемый для разрешения перегрузок в Groovy, можно описать следующими словами \cite{groovy:selectingOverloadsAtRuntime}.

\begin{enumerate}
    \item Создать список всех методов с подходящих именем.
    \item Удалить методы, которые не подходят к текущему вызову.
    \item Если текущий список содержит ровно один элемент, то выбираем его и завершаем процесс поиска перегрузки.
    \item Для всех методов считаем метрику \textit{расстояние между методами}, вычисленной между типами аргументов каждого метода и реальными аргументами переданными в него.
    \item Если есть метод, на котором достигается строгий минимум метрики, то выбираем этот метод и завершаем процесс поиска перегрузки.
    \item Завершаем процесс выбора перегрузки с неудачей.
\end{enumerate}

Для рассчёта метрики \textit{расстояние между методами}, мы можем воспользоваться следующим алгоритмом:
\begin{enumerate}
    \item Для произвольного аргумента метода, который является кандидатом на разрешение перегрузки, считаем расстояние в иерархии наследования между этим типом, и типом времени исполнения параметра, переданного в этот аргумент.
    \item Метрикой для конкретного метода-кандидата является сумма метрик посчитопанных для всех его аргументов, согласно правилу описанному на первом шаге.
\end{enumerate}


\subsubsection{Подход С{\#}}

В C{\#}, при разрешении перегрузок, методы-кандидаты выбираются из следующих наборов \cite{csharp:languageSpecification}:

\begin{itemize}
    \item Вызов именованного метода, посредством использования вызываемого выражения.
    \item Вызов именованного конструктора, посредством использования вызываемого выражения создающего нвоый объект.
    \item Вызов метода доступа по индексу.
    \item Вызов предопределённого или пользовательского оператора, участвовавшего в выражении.
\end{itemize}

Каждый из вышеперечисленных наборов задают множество кандидатов. Рассмотрев объединение этих множеств, очищенное от методов неподходящих по имени или с неподходящим набором аргументов, можно определить лучший метод, согласно следующим правилам:

\begin{itemize}
    \item Если целевое множество содержит ровно один метод, то он признаётся лучшим.
    \item В противном случае, лучшим методом считается тот, который лучше всех остальных методов, с учётом их списков аргументов. Целевой метод определяется путём её сравнивания со всеми другими кандидатами \textit{специальным предикатом}, который должен показать истину при всех сравнениях.
    \item Если мы не смогли успешно определить лучший метод, то мы считаем что текущий выбор является неоднозначным, и мы продуцируем ошибку во время выполнения.
\end{itemize}

Определение лучшего метода довольно объёмно, поэтому желающие могут ознакомиться в главе 7.5.3.2 Better function member \cite{csharp:languageSpecification}.


\subsection{Предложенное взаимодействие с динамическим кодов в Kotlin}

На основании обзора особенностей других языком, сформируем правила, как должны происходить операции, участниками которых являются динамические переменные. Нам стоит обсудить несколько типов операций.

\begin{itemize}
    \item Присваивание в динамическую переменную
    \item Присваивание динамической переменной в типизированную
    \item Вызов метода на динамической переменной
    \item Вызов метода на типизированной переменной
    \item Запрос поля у динамической переменной
    \item Запрос динамического поля у не динамической переменной
\end{itemize}

При присваивании в динамическую переменную, мы будем ожидать точно такое же поведение как при присваивании в класс \textit{Any?}.

При присваивании динамической переменной в типизированную, мы хотим ожидать такое же поведение как при привидении \textit{Any?} к этому типу --- во время выполнения должна произойти проверка, что данное присваивание действительно может произойти, принимая во внимание иерархию наследования.

При вызове метода на динамической переменной, мы хотим чтобы среди всех методов,  которые можно вызвать на типе, лежащем в динамической переменной, выбрался такой, что:
\begin{enumerate}
    \item Его имя совпадает с динамически вызванным методом. \label{tbl:better1}
    \item К его аргументам подходят аргументы времени выполнения у динамического метода. \label{tbl:better2}
    \item Он является \textit{более специфичный}, чем все другие методы, которые удовлетворяют \ref{tbl:better1}-\ref{tbl:better2}.
\end{enumerate}

Если у нас не получилось выбрать метод согласно вышеуказанным правилам, мы хотим получать исключение времени исполнения.

Про два типа $\phi$ и $\psi$, будем говорить:
\begin{itemize}
    \item Что $\phi$ и $\psi$ \textit{эквивалентные типы}, если они в точности совпадают.
    \item Что $\phi$ и $\psi$ \textit{похожие типы}, если один из них, является упакованной\footnotemark версией другого.
    \item Что $\phi$ \textit{лучший тип} чем  $\psi$, если $\phi$ реализует интерфейс $\psi$, или является его потомком.
    \item Во всех других случаях, будем говорить, что $\phi$ \textit{худший тип}, чем $\psi$.
\end{itemize}

\footnotetext{Про упаковку будет рассказано в главе \ref{sec:connectKotlinWithJava}.}

Для сравнения специфичности методов $f(\{a_i\})$ и $g(\{b_i\})$, можно использовать следующий алгоритм:

\begin{enumerate}
    \item Если $f$ совпадает с $g$, то он \textit{более специфичный} чем $g$.
    \item Если $f$ является методом помощником, то он \textit{более специфичный} чем $g$.
    \item Если $g$ является методом помощником, то он \textit{менее специфичный} чем $f$.
    \item Если возвращаемый тип $f$ \textit{лучше}, чем тип \textit{g}, то $f$ \textit{более специфичный}.
    \item Если возвращаемый тип $f$ \textit{хуже}, чем тип \textit{g}, то $f$ \textit{менее специфичный}.
    \item Если у $f$ существует такой индекс \textit{i}, что \textit{i}-ый параметр $f$ \textit{хуже} чем \textit{i}-ый параметр \textit{g}, то $f$ \textit{менее специфичный} чем $g$.
    \item Если у $f$ существует такой индекс \textit{i}, что \textit{i}-ый параметр $f$ \textit{лучше} чем \textit{i}-ый параметр \textit{g}, то $f$ \textit{более специфичный} чем $g$.
    \item Если $g$ является методом с переменным числом аргументов, а $f$ --- нет, то $f$ \textit{более специфичный}.
    \item Во всех остальных случаях, $f$ \textit{менее специфичный}.
\end{enumerate}

При вызове метода на типизированной переменной, мы пробуем запустить разрешить перегрузку во время компиляции, считая что \textit{dynamic} это наименее специфичный тип из всех. Стоит отметить, что это может вызывать некоторые не интуитивные ситуации, например если у нас есть две перегрузки:

\begin{minted}[mathescape,
               linenos,
               numbersep=5pt,
               gobble=2,
               frame=lines,
               framesep=2mm]{kotlin}
    fun foo(s: String)
    fun foo(d: dynamic)
\end{minted} 

То следующие вызовы будут разрешены в пользу перегрузки \mintinline{kotlin}{foo(String)}:

\begin{minted}[mathescape,
               linenos,
               numbersep=5pt,
               gobble=2,
               frame=lines,
               framesep=2mm]{kotlin}
    foo("")
    foo(dyn) // dyn: dynamic
\end{minted} 

С другой стороны, вызов \mintinline{kotlin}{foo(1)}, будет разрешён в пользу \mintinline{kotlin}{foo(dynamic)}, потому что он не подходит к никаким другим перегрузкам.

При запросе поля у динамической переменной, мы хотим следующее поведение:

\begin{itemize}
    \item Если у класса объекта, который в данный момент находится в ней, существует поле с запрошенным именем, мы хотим получить значение этого поля на текущем объекте.
    \item В противном случае, мы хотим получить исключение времени исполнения.
\end{itemize}

При запросе динамического поля у типизированной переменной, мы хотим такое же поведение, как при запросе обычного поля класса.