\section{Подход к решению задачи}

%ПЕРЕМЕСТИТЬ В ОБЗОР ЛИТЕРАТУРЫ, В КОНЕЦ, ОПИСАТЬ ПРО ДРКГИЕ ИНСТРУКЦИИ ВЫЗОВА.
В этом разделе мы рассмотрим ситуации, в которых проявляется [ПЕРЕПИШИ]

\subsection{Обзор ситуаций требующих изменения вызываемого метода}
\label{sec:methodChangeOverview}

Рассмотрим подробно ситуации в языке Kotlin, в которых у нас может возникнуть желание поменять решение о выборе метода, который мы будем вызывать.

\begin{minted}[mathescape,
               linenos,
               numbersep=5pt,
               gobble=2,
               frame=lines,
               framesep=2mm]{kotlin}
    receiver.field
\end{minted}

Предположим, во время компиляции, переменная \textit{receiver}, помечена как \textit{dynamic}. При осуществлении первого
вызова мы должны запустить \textit{процесс разрешения свойства класса или поля}.
%Предположим, во время компиляции, переменная \textit{receiver}, помечена как \textit{dynamic}. При осуществлении первого %вызова мы должны запустить \textit{процесс разрешения свойства класса или поля}, при котором мы можем попасть в одну %из трёх ситуаций:

%\begin{itemize}
    %\item У типа, который принимает переменная \textit{receiver}, во время выполнения, есть поле \textit{field}, но нету %метода \textit{getField()}. Тогда мы должны текущий вызов связать с получением этого поля.
    %\item У типа, который принимает переменная \textit{receiver}, во время выполнения, нету поля \textit{field}, но есть %метод \textit{getField()}. Тогда мы должны текущий вызов связать с вызовом этого метода.
    %\item У типа, который принимает переменная \textit{receiver}, во время выполнения, есть поле \textit{field} и метод %\textit{getField()}. Тогда мы должны текущий вызов связать с получением этого поля \textit{field}, потому что так %происходит в языке Kotlin при статической типизации.
%\end{itemize}

При повторном вызове, в зависимости от изменения типа, который принимает переменная \textit{receiver}, во время выполнения, у нас может быть две ситуации:

\begin{itemize}
    \item Тип не изменился. Тогда мы имееем право вызвать то же поле или метод, которые мы разрешили при первом вызове.
    \item Тип изменился. Тогда мы не можем точно сказать что мы должны сейчас вызвать, и мы должны снова запустить \textit{процесс разрешения поля или свойства класса}.
\end{itemize}

\begin{minted}[mathescape,
               linenos,
               numbersep=5pt,
               gobble=2,
               frame=lines,
               framesep=2mm]{kotlin}
    receiver.field = object
\end{minted}

Ситуация присваивания значения полю или вычислимому свойству разрешается аналогично предыдущему пункту, проверяя изменение типа объекта лежащего в переменной \textit{receiver}.

\begin{minted}[mathescape,
               linenos,
               numbersep=5pt,
               gobble=2,
               frame=lines,
               framesep=2mm]{kotlin}
    receiver.method(arg1, ..., argN)
\end{minted}

Предположим, во время компиляции, переменная \textit{receiver}, помечена как \textit{dynamic}. При осуществлении первого
вызова мы должны запустить \textit{процесс разрешения целевого метода}.

При повторном вызове, нам также необходимо проверить изменения типа  \textit{receiver}. Так как язык Kotlin поддерживает перегрузку методов по типам аргументов, нам также необходимо проверить изменения типов всех аргументов $arg_i$. Существует ещё одна ситуация. При первом вызове может обнаружиться, что у класса, представителем которого является \textit{receiver}, нету метода \textit{method}, но зато есть поле или свойство класса \textit{method}, по которому лежит объект, который может быть вызван. Такие объекты характеризуются тем, что у них есть как минимум один метод с именем \textit{invoke}, помеченный что он является оператором \cite{book:jemerov2017kotlininAction}. Заметим что при наличии нескольких таких методов, нам необходимо запускать процедуру определения нужной перегрузки. Таким образом, чтобы осуществить требуемый вызов, нам необходимо вызвать получение значения поля \textit{method}, и на этом значении вызывать нужный метод с учётом перегрузок. Поэтому знания того, что класс объекта лежащего в \textit{receiver} нам недостаточно. Нам необходимо ещё знать что тот объект, который лежит в поле \textit{method} или возвращается соответсвенным свойством класса, не изменился.



\subsection{Разрешение перегрузок}

Заметим, что используя только знания о типах, которые мы получаем из самих объектов во время исполнения, мы не сможем добиться такого же разрешения перегрузок, как во время компиляции. Это можно проиллюстрировать следующим примером на языке C{\#}.

\begin{minted}[mathescape,
               linenos,
               numbersep=5pt,
               gobble=2,
               frame=lines,
               framesep=2mm]{csharp}
    public class Base {};
    public class Derived : Base {};
    
    public class A {
        public String method1(Base b) {
            return "Base";
        }
        public String method1(Derived b) {
            return "Derived";
        }
    }
\end{minted}

Если мы попробуем вызвать метод \textit{method1} класса \textit{A}, передав ему переменную  \mintinline{csharp}{Base b = new Derived()}, то мы получим в результате строку \textit{Base}. Потому что выбор будет происходить согласно статическим типам. Рассмотрим динамический случай \mintinline{csharp}{dynamic b = (Base) new Derived()}.
Без дополнительного хранения памяти о статических типах, мы не можем узнать во время исполнения статический тип b. Поэтому при передаче b в метод \textit{method1}, мы получим строку \textit{Derived}.

Также заметим, что коль скоро, выбор необходимой перегрузки должен происходить во время исполнения, становится критичен вопрос производительности нашего решения.

\subsubsection{Подход Groovy}

Алгоритм используемый для разрешения перегрузок в Groovy, можно описать следующими словами \cite{groovy:selectingOverloadsAtRuntime}.

\begin{enumerate}
    \item Создать список всех методов с подходящих именем.
    \item Удалить методы, которые не подходят к текущему вызову.
    \item Если текущий список содержит ровно один элемент, то выбираем его и завершаем процесс поиска перегрузки.
    \item Для всех методов считаем метрику \textit{расстояние между методами}, вычисленной между типами аргументов каждого метода и реальными аргументами переданными в него.
    \item Если есть метод, на котором достигается строгий минимум метрики, то выбираем этот метод и завершаем процесс поиска перегрузки.
    \item Завершаем процесс выбора перегрузки с неудачей.
\end{enumerate}

Для рассчёта метрики \textit{расстояние между методами}, мы можем воспользоваться следующим алгоритмом:
\begin{enumerate}
    \item Для произвольного аргумента метода, который является кандидатом на разрешение перегрузки, считаем расстояние в иерархии наследования между этим типом, и типом времени исполнения параметра, переданного в этот аргумент.
    \item Метрикой для конкретного метода-кандидата является сумма метрик посчитопанных для всех его аргументов, согласно правилу описанному на первом шаге.
\end{enumerate}


\subsubsection{Подход С{\#}}

В C{\#}, при разрешении перегрузок, методы-кандидаты выбираются из следующих наборов \cite{csharp:languageSpecification}:

\begin{itemize}
    \item Вызов именованного метода, посредством использования вызываемого выражения.
    \item Вызов именованного конструктора, посредством использования вызываемого выражения создающего нвоый объект.
    \item Вызов метода доступа по индексу.
    \item Вызов предопределённого или пользовательского оператора, участвовавшего в выражении.
\end{itemize}

Каждый из вышеперечисленных наборов задают множество кандидатов. Рассмотрев объединение этих множеств, очищенное от методов неподходящих по имени или с неподходящим набором аргументов, можно определить лучший метод, согласно следующим правилам:

\begin{itemize}
    \item Если целевое множество содержит ровно один метод, то он признаётся лучшим.
    \item В противном случае, лучшим методом считается тот, который лучше всех остальных методов, с учётом их списков аргументов. Целевой метод определяется путём её сравнивания со всеми другими кандидатами \textit{специальным предикатом}, который должен показать истину при всех сравнениях.
    \item Если мы не смогли успешно определить лучший метод, то мы считаем что текущий выбор является неоднозначным, и мы продуцируем ошибку времени связывания.
\end{itemize}

Определение лучшего метода довольно объёмно, поэтому желающие могут ознакомиться в главе 7.5.3.2 Better function member \cite{csharp:languageSpecification}.


\subsection{Предложенное взаимодействие с динамическим кодов в Kotlin}

На основании обзора особенностей других языком, сформируем правила, как должны происходить операции, участниками которых являются динамические переменные. Нам стоит обсудить несколько типов операций.

\begin{itemize}
    \item Присваивание в динамическую переменную
    \item Присваивание динамической переменной в типизированную
    \item Вызов метода на динамической переменной
    \item Вызов метода на типизированной переменной
    \item Запрос поля у динамической переменной
    \item Запрос динамического поля у не динамической переменной
\end{itemize}

При присваивании в динамическую переменную, мы будем ожидать точно такое же поведение как при присваивании в класс \textit{Any?}.

При присваивании динамической переменной в типизированную, мы хотим ожидать такое же поведение как при привидении \textit{Any?} к этому типу --- во время выполнения должна произойти проверка, что данное присваивание действительно может произойти, принимая во внимание иерархию наследования.

При вызове метода на динамической переменной, мы хотим чтобы среди всех методов, которые можно вызвать на типе, который сейчас лежит в динамической переменной, выбрался такой, что:
\begin{enumerate}
    \item Его имя совпадает с динамически вызванным методом. \label{tbl:better1}
    \item К его аргументам подходят аргументы времени выполнения у динамического метода. \label{tbl:better2}
    \item Он является \textit{более специфичный}, чем все другие методы, которые удовлетворяют \ref{tbl:better1}-\ref{tbl:better2}.
\end{enumerate}

Если у нас не получилось выбрать метод согласно вышеуказанным правилам, мы хотим получать исключение времени исполнения.

Про два типа $\phi$ и $\psi$, будем говорить:
\begin{itemize}
    \item Что $\phi$ и $\psi$ \textit{эквивалентные типы}, если они в точности совпадают.
    \item Что $\phi$ и $\psi$ \textit{похожие типы}, если один из них, является упакованной версией другого.
    \item Что $\phi$ \textit{лучший тип} чем  $\psi$, если $\phi$ реализует интерфейс $\psi$, или является его потомком.
    \item Во всех других случаях, будем говорить, что $\phi$ \textit{худший тип}, чем $\psi$.
\end{itemize}

Для сравнения специфичности методов $f(\{a_i\})$ и $g(\{b_i\})$, можно использовать следующий алгоритм:

\begin{enumerate}
    \item Если $f$ совпадает с $g$, то он \textit{более специфичный} чем $g$.
    \item Если $f$ является методом помощником, то он \textit{более специфичный} чем $g$.
    \item Если $g$ является методом помощником, то он \textit{менее специфичный} чем $f$.
    \item Если возвращаемый тип $f$ \textit{лучше}, чем тип \textit{g}, то $f$ \textit{более специфичный}.
    \item Если возвращаемый тип $f$ \textit{хуже}, чем тип \textit{g}, то $f$ \textit{менее специфичный}.
    \item Если у $f$ существует такой индекс \textit{i}, что \textit{i}-ый параметр $f$ \textit{хуже} чем \textit{i}-ый параметр \textit{g}, то $f$ \textit{менее специфичный} чем $g$.
    \item Если у $f$ существует такой индекс \textit{i}, что \textit{i}-ый параметр $f$ \textit{лучше} чем \textit{i}-ый параметр \textit{g}, то $f$ \textit{более специфичный} чем $g$.
    \item Если $g$ является методом с переменным числом аргументов, а $f$ --- нет, то $f$ \textit{более специфичный}.
    \item Во всех остальных случаях, $f$ \textit{менее специфичный}.
\end{enumerate}

При вызове метода на типизированной переменной, мы пробуем запустить разрешить перегрузку во время компиляции, считая что \textit{dynamic} это наименее специфичный тип из всех. Стоит отметить, что это может вызывать некоторые неинтуитивные ситуации, например если у нас есть две перегрузки:

\begin{minted}[mathescape,
               linenos,
               numbersep=5pt,
               gobble=2,
               frame=lines,
               framesep=2mm]{kotlin}
    fun foo(s: String)
    fun foo(d: dynamic)
\end{minted} 

То следующие вызовы будут разрешены в пользу перегрузки \mintinline{kotlin}{foo(String)}:

\begin{minted}[mathescape,
               linenos,
               numbersep=5pt,
               gobble=2,
               frame=lines,
               framesep=2mm]{kotlin}
    foo("")
    foo(dyn) // dyn: dynamic
\end{minted} 

С другой стороны, вызов \mintinline{kotlin}{foo(1)}, будет разрешён в пользу \mintinline{kotlin}{foo(dynamic)}, потому что он не подходит к никаким другим перегрузкам.

При запросе поля у динамической переменной, мы хотим следующее поведение:

\begin{itemize}
    \item Если у класса объекта, который в данный момент находится в ней, существует поле с запрошенным именем, мы хотим получить значение этого поля на текущем объекте.
    \item В противном случае, мы хотим получить исключение времени исполнения.
\end{itemize}

При запросе динамического поля у типизированной переменной, мы хотим такое же поведение, как при запросе обычного поля класса.