\vfill
\clearpage
\section*{Заключение}


%В настоящей работе мы представили динамическое поведение языка Kotlin. Для данного поведения мы рассмотрели его возможную реализацию. Мы рассмотрели множество примеров кода, на основании тестирования которого, мы пришли к выводу, что динамически типизацированное решение во многих случаях работает не хуже чем , чем аналогичный статически типизированный код на языке Kotlin. На основании этого кода мы можем сделать вывод, что аналогичный динамически типизированный код на языке Groovy заметно медленней.

В рамках даннной работы были достигнуты следующие результаты:

\begin{itemize}
    \item Были рассмотренны динамические поведения в языках с постепенной типизацией.
    \item Было предложено динамическое поведение в языке Kotlin.
    \item Была реализована библиотека определяющая ссылки на методы во время выполнения программы, принимающая во внимание наличие перегрузок.
    \item Были предложены изменения для компилятора Kotlin, поддерживающие это динамическое поведение.
    \item Были проведены замеры производительности предложенного решения, которые были сравнены с решением языка Groovy.
        \item По итогам замеров производительности, предложенное решение обгоняет Groovy и решение Groovy базирующее на инструкции \textit{invokedynamic} в несколько раз.
\end{itemize}

Настоящая работа имеет возможное продолжение. Оно заключается в поиске ответов на следующие вопросы:

\begin{itemize}
    \item Имеет ли смысл динамическое разрешение вызовов, осуществлённых на статически разрешаемой переменной.
    \item Как должен осуществляться вызов со статически неизвестным получателем. Как должен осуществляться этот поиск. 
    \begin{minted}[mathescape,
               numbersep=5pt,
               gobble=2,
               frame=lines,
               framesep=2mm]{kotlin}
    println(dyn)
\end{minted}
    \item Возможно ли взаимодействие с кодом на Groovy из кода написанного на языке Kotlin.
\end{itemize}