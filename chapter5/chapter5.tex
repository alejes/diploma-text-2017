\vfill
\clearpage
\section*{Заключение}


%В настоящей работе мы представили динамическое поведение языка Kotlin. Для данного поведения мы рассмотрели его возможную реализацию. Мы рассмотрели множество примеров кода, на основании тестирования которого, мы пришли к выводу, что динамически типизацированное решение во многих случаях работает не хуже чем , чем аналогичный статически типизированный код на языке Kotlin. На основании этого кода мы можем сделать вывод, что аналогичный динамически типизированный код на языке Groovy заметно медленней.
Настоящая работа посвящена поддержке динамической типизации в языке Kotlin при компиляции в Java байт-код.
%В рамках данной работы было рассмотрено динамическое поведение в языках с постепенной типизацией на примере Groovy и C\#. На основании анализа этого поведения, 
В работе была предложена семантика динамических операций в языке Kotlin. В рамках реализации этого поведения, была написана библиотека, определяющая во время выполнения программы ссылки на методы с учётом перегрузок. В работе были описаны изменения компилятора Kotlin, реализующие разработанное динамическое поведение. 

Для получения представления об эффективности разработанного решения, были проведены замеры производительности, которые были сравнены с производительностью языка Groovy.
Измерения показали, что при отсутствии активной смены типов в месте вызова, предложенное решение эффективней решения Groovy более чем в 3 раза. При однопоточной активной смене типов в точке вызова, существует модификация решения, которая в среднем быстрее в 3.49 раз, чем решение Groovy. Однако в многопоточной версии, при активной смене типов, решение пока проигрывает в среднем в 2.11 раз.
% В реализации использованы такие-то техники кеширования и получилось во столько-то раз быстрее groovy.

%FUTURE 3 основных и один абзац текста

В качестве дальнейших направлений исследования можно рассмотреть следующие предложения. Будет полезно реализовать вызов методов на статически разрешённой переменной, одним из переданных аргументов которой является переменная динамического типа. Для повышения удобства написания динамического кода стоит разработать проверки времени компиляции в тех случаях, в которых множество потенциальных кандидатов можно определить до момента выполнения. Особый интерес состоит в задаче предоставления возможности вызова из языка Kotlin динамического кода, написанного на языке Groovy.
% Оно заключается в поиске ответов на следующие вопросы:

% \begin{itemize}
%     \item Как вызывать методы на статически разрешённой переменной, если одним из переданных аргументов является переменная динамического типа.
%     \item Имеет ли смысл динамическое разрешение вызовов, осуществлённых на статически разрешаемой переменной.
%     \item Какие проверки динамического кода должны производиться во время компиляции.
%     Например, можно сделать проверки аналогичные проверкам производимым C\#, рассмотренным в разделе \ref{sec:dynamicBehaviorSCharp}. 
%     \item Как можно усовершенствовать систему запоминая разрешённых перегрузок методов.
%     \item Как должны осуществляться вызовы, для которых статически неизвестен объект, на которых они осуществляются. Особый интерес представляет способ осуществления поиска вызываемого метода. 
%     \begin{minted}[mathescape,
%               numbersep=5pt,
%               gobble=2,
%               frame=lines,
%               framesep=2mm]{kotlin}
%     println(dyn)
% \end{minted}
% В предложенном примере кода, \textit{println} может быть, например, вызовом функции из пакета \textit{kotlin.io}, или может быть вызовом динамической переменной с именем \textit{println}, которая является объектом поддерживающим операции вызова. Узнать какую перегрузку мы должны выбрать, мы сможем только во время исполнения.
%     \item Возможно ли взаимодействие с кодом на Groovy из кода написанного на языке Kotlin.
% \end{itemize}