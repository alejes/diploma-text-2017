\vfill
\clearpage
\section*{Заключение}


%В настоящей работе мы представили динамическое поведение языка Kotlin. Для данного поведения мы рассмотрели его возможную реализацию. Мы рассмотрели множество примеров кода, на основании тестирования которого, мы пришли к выводу, что динамически типизацированное решение во многих случаях работает не хуже чем , чем аналогичный статически типизированный код на языке Kotlin. На основании этого кода мы можем сделать вывод, что аналогичный динамически типизированный код на языке Groovy заметно медленней.

В рамках данной работы было рассмотрено динамическое поведения в языках с постепенной типизацией Groovy и C\#. На основании анализа этого поведения, было предложено динамическое поведение в языке Kotlin. В рамках реализации динамического поведения, была написана библиотека определяющая ссылки на методы во время выполнения программы, принимающая во внимание наличие перегрузок. В работе были предложены изменения для компилятора Kotlin, поддерживающие разработанное динамическое поведение. Для получения представления об эффективности разработанного решения, были проведены замеры производительности предложенного решения, которые были сравнены с производительностью решения языка Groovy.
Замеры производительности показали, что представленное решение быстрее в несколько раз.

Настоящая работа имеет возможное продолжение. Оно заключается в поиске ответов на следующие вопросы:

\begin{itemize}
    \item Как вызывать методы на статически разрешённой переменной, если одним из переданных аргументов является переменная динамического типа.
    \item Имеет ли смысл динамическое разрешение вызовов, осуществлённых на статически разрешаемой переменной.
    \item Какие проверки динамического кода должны производиться во время компиляции.
    Например, можно сделать проверки аналогичные проверкам производимым C\#, рассмотренным в разделе \ref{sec:dynamicBehaviorSCharp}. 
    \item Как можно усовершенствовать систему запоминая разрешённых перегрузок методов.
    \item Как должны осуществляться вызовы со статически неизвестным получателем. Особый интерес представляет способ осуществления поиска вызываемого метода. 
    \begin{minted}[mathescape,
               numbersep=5pt,
               gobble=2,
               frame=lines,
               framesep=2mm]{kotlin}
    println(dyn)
\end{minted}
В предложенном примере кода, \textit{println} может быть, например, вызовом функции из пакета \textit{kotlin.io}, или может быть вызовом динамической переменной с именем \textit{println}, в которой лежит объект поддерживающий операции вызова. Узнать какую перегрузку мы должны выбрать, мы сможем только во время исполнения.
    \item Возможно ли взаимодействие с кодом на Groovy из кода написанного на языке Kotlin.
\end{itemize}