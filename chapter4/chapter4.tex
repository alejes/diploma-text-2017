\section{Измерения производительности}

Одним из важных вопросов при использовании динамического кода является его производительность. При статической типизации множество проверок и вычислений происходят во время компиляции, тогда как при динамической типизации их приходится производить во время выполнения. Такие проверки могут сильно сказываться на времени работы программы.

\subsection{Особенности измерения производительности на Java платформе}

Важным фактором в любом измерении является степень доверия результату. Код, предназначенный для Java платформы, запускается при помощи виртуальной машины, поэтому нам необходимо учитывать её особенности. Во время выполнения, Java машина часть байт-кода может интерпретировать, выполняя инструкцию за инструкцией, а часть --- компилировать в машинный код. Машинный код выполняется быстрее чем интерпретируемый, однако требует время на свою генерацию. Во время работы, Java машина накапливает статистику по выполняемому коду, на основании которой, она может решать каким способом выполнять каждый участок кода и производить различные оптимизации. Часто, чтобы позволить JVM накопить статистическую информацию, перед замером выполняют несколько, так называемых <<разогревочных>>, запусков.

С накоплением достаточного количество статистики, возникает ещё одна проблема. Часть кода может быть удалена, потому что Java машина посчитает что этот код никак не используется и не влияет на результат работы программы. Также, если во время выполнения станет ясно что результат работы некоторых методов не зависит от внешних факторов, их вызов быть заменён на результат их вычисления. Выполнение замеров производительности на оптимизированном коде даёт ложную картину о скорости работы программы.

Во время выполнения <<разогревочных>> запусков, виртуальная машина Java также накапливает информацию об используемой памяти. На основании этой информации, JVM может выделить для себя большее или меньшее количество памяти. Если JVM не хватает свободной памяти, она может запустить процедуру \textit{сборки мусора} --- процесс поиска и удаления объектов, которые ещё лежат в памяти, но уже не нужны для выполнения программы. Сама процедура сборки мусора может занимать достаточно внушительное время, серьёзно влияя на время работы замеряемого участка кода.

Для повышения точности показателей, при выполнении замеров времени работы программы, рекомендуется отключать сторонние приложения. Ввиду особенности обеспечения планирования процессов в многозадачных системах, отключая приложения мы можем уменьшить влияние фактора того, что планировщик имеет возможность снимать процесс JVM с выполнения.

Одним из популярных способов уменьшить количество проблем при измерениях написанного для JVM платформы кода, является использованием специального программного инструмента --- JMH \cite{java:jmh}. Данный программный инструмент, путём передачи ему определённых параметров, самостоятельно обеспечивает требуемое количество <<разогревочных>> запусков. В рамках каждого из основных запусков, каждый тест производительности запускается несколько раз, после чего вычисляется среднее время работы в рамках этого запуска. Результаты всех запусков представляются как выборка из нормального распределения, с неизвестной дисперсией. По полученной выборке можно рассчитать различные характеристики случайной величины, например математическое ожидание и доверительный интервал.

    Для того чтобы избежать удаления неиспользуемого кода, JMH предоставляет специальный объект типа \textit{Blackhole}. Передача результата в этот объект позволяет избежать случая, при котором Java машина считает что результат операции ни на что не влияет, и не выполняет часть кода.

\subsection{Окружение при проведении измерений производительности}

\begin{itemize}
    \item \textbf{Операционная система:} Linux version 4.4.0-71-generic (buildd\at lcy01-05) (gcc version 5.4.0 20160609 (Ubuntu 5.4.0-6ubuntu1~16.04.4) ) \#92-Ubuntu SMP Fri Mar 24 12:59:01 UTC 2017.
    \item \textbf{Центральный процессор:}  Intel(R) Core(TM) i7-6700 CPU \at 3.40GHz.
    \item \textbf{Версия JVM:}  Java HotSpot(TM) 64-Bit Server VM (build 25.121-b13, mixed mode).
    \item \textbf{Версия JRE:}  Java(TM) SE Runtime Environment (build 1.8.0\_121-b13).
\end{itemize}


\subsection{Рассмотренные тесты производительности}

В рамках данной работы был разработан набор тестов производительности, для оценки практичности решения. Будут сравниваться решения на языках Kotlin и Groovy. В языке Groovy, начиная с версии 2.0, появилась поддержка инструкции \textit{invokedynamic} JVM платформы \cite{groovy:invokeDynamicSupport}. Есть измерения, что в некоторых случаях, Groovy код, скомпилированный с поддержкой данной инструкции, работает быстрее \cite{groovy:indyTest1}.
В каждом тесте производится сравнение одинакового кода, переписанного с учётом особенностей каждого языка или способа компиляции. В качестве целевых платформ, для тестирования производительности, использовались следующие:

\begin{itemize}
    \item Kotlin (статическая типизация, версия 1.1 rc) 
    \item Kotlin (максимально возможное число объектов помечено типом \textit{dynamic}, на основе версии 1.1 rc)
    \item Groovy (версия 2.4.5)
    \item Groovy Invoke Dynamic (версия 2.4.5)
    \item Groovy (с аннотацией CompileStatic) (версия 2.4.5)
\end{itemize}


Для поддержания объективности, каждый тест производился на всех целевых платформах, при различных размерах входных данных. Исходный код тестов для всех платформ, можно найти в репозитории \cite{github:myBenchs}. При анализе результатов, основное внимание мы будем обращать на следующее:

\begin{itemize}
    \item Относительное различие статически и динамически типизированного кода.
    \item Сравнение скорости работы динамической типизированного кода на языке Kotlin, с динамически типизируемым кодом Groovy (при компиляции <<обычным способом>> и с помощью \textit{invokedynamic} инструкции.
\end{itemize}

Для удобства анализа результатов, мы будем сортировать данные по увеличению времени работы. В качестве времени работы, мы будем замерять время выполнения одного запуска теста в секундах. Перед запуском тестов мы будем проводить 20 <<разогревочных>> итераций. После этого мы будем запускать код на выполнение ещё 20 раз в рамках <<основных>> итераций. На основании всех результатов <<основных>> итераций, мы будем вычислять ошибку --- максимальное замеченное отклонение, относительно посчитанного времени работы.

\subsubsection{Вычисление чисел Фибоначчи}

Числа Фибоначчи представляют собой возрастающую последованность, в которой первые два элемента равны 1, а следующие равны сумме двух предыдущих \cite{math:vilenkin1969Combinatorics}. Данный тест реализован в рекурсивном варианте решения, в котором расчёт результирующего значения для \textit{i}-го элемента, выполняется путём запуска вычисления алгоритма от \textit{i-1}-го, и \textit{i-2}-го элемента, без выполнения каких-то техник запоминания промежуточных результатов.

\begin{table}[h]
\caption{\label{tab:fibBenchResults}Результаты теста: Числа Фибоначчи}
\begin{center}
\begin{tabular}{|l|l|l|l|}
\hline
Способ компиляции & Параметр & Время работы & Ошибка \\
\hline
Kotlin (статическая типизация)           & 10  &     0.168 & ±   0.001  \\
Groovy (статическая типизация)           & 10  &     0.169 & ±   0.001  \\
Kotlin (динамическая типизация)          & 10  &     0.414 & ±   0.001  \\
Groovy (invokedynamic)                   & 10  &     0.971 & ±   0.015  \\
Groovy (динамическая типизация)          & 10  &     2.062 & ±   0.002  \\
Kotlin (статическая типизация)           & 20  &    20.252 & ±   0.012  \\
Groovy (статическая типизация)           & 20  &    21.342 & ±   0.006  \\
Kotlin (динамическая типизация)          & 20  &    61.291 & ±   0.242  \\
Groovy (invokedynamic)                   & 20  &   120.601 & ±   4.669  \\
Groovy (динамическая типизация)          & 20  &   329.291 & ±   2.147  \\
Kotlin (статическая типизация)           & 30  &  2543.617 & ±  32.751  \\
Groovy (статическая типизация)           & 30  &  2623.825 & ±   0.938  \\
Kotlin (динамическая типизация)          & 30  &  7511.847 & ±  20.879  \\
Groovy (invokedynamic)                   & 30  & 14536.611 & ±  31.977  \\
Groovy (динамическая типизация)          & 30  & 39282.635 & ± 770.146  \\
\hline
\end{tabular}
\end{center}
\end{table} 


Согласно таблице \ref{tab:fibBenchResults} мы видим, что решение рассмотренное в настоящей работе обыгрывает динамические решения в языке Groovy. По сравнению с типизированным решением, динамическое проигрывает примерно в три раза.


\subsubsection{Возведение матрицы в квадрат}

Перемножение матриц является классической задачей для тестирования производительности. В рамках нашей задачи нету необходимости вдаваться в тонкости оптимизаций размещения матрицы в памяти. Мы будем возводить в матрицу, хранящуюся как массив массивов чисел, в квадрат, по стандартной формуле произведения матриц, описанной например в \cite{book:KryakvinVadimDLinAlgebra}. 

\begin{table}[h]
\caption{\label{tab:matrixSquareBenchResults}Результаты теста: Возведение матрицы в квадрат}
\begin{center}
\begin{tabular}{|l|l|l|l|}
\hline
Способ компиляции & Параметр	& Время работы & Ошибка \\
\hline
Kotlin (статическая типизация)            & 10 &   11.363 & ±  0.019 \\
Kotlin (динамическая типизация)           & 10 &   18.401 & ±  0.266 \\
Groovy (статическая типизация)            & 10 &   27.111 & ±  3.051 \\
Groovy (invokedynamic)                    & 10 &   77.666 & ±  0.436 \\
Groovy (динамическая типизация)           & 10 &   79.620 & ±  0.235 \\
Kotlin (статическая типизация)            & 20 &   84.300 & ±  0.227 \\
Kotlin (динамическая типизация)           & 20 &  128.495 & ±  0.353 \\
Groovy (статическая типизация)            & 20 &  141.465 & ±  0.648 \\
Kotlin (статическая типизация)            & 30 &  293.453 & ±  0.514 \\
Kotlin (динамическая типизация)           & 30 &  429.133 & ±  3.847 \\
Groovy (статическая типизация)            & 30 &  461.751 & ±  4.854 \\
Groovy (invokedynamic)                    & 20 &  595.588 & ±  2.486 \\
Groovy (динамическая типизация)           & 20 &  612.050 & ±  7.252 \\
Groovy (invokedynamic)                    & 30 & 1996.972 & ±  5.953 \\
Groovy (динамическая типизация)           & 30 & 2453.174 & ± 10.239 \\
\hline
\end{tabular}
\end{center}
\end{table} 


Согласно таблице \ref{tab:matrixSquareBenchResults} мы видим, что решение рассмотренное в настоящей работе обыгрывает динамические решения в языке Groovy.

\subsubsection{Z-функция}


Z-функция от какой-то строки --- массив совпадающий с ней по длине, в которой i-ый элемент, совпадает с числом символов, которые начиная с i-ой позиции, совпадают с первыми символами данной строки. Z-функция помогает решать множество задач связанных с поиском подстрок в строке.
Детали её реализации подробно описаны например в \cite{algo:gusfield1997algorithms}.

\begin{table}[h]
\caption{\label{tab:zFunctionBenchResults}Результаты теста: Z-функция}
\begin{center}
\begin{tabular}{|l|l|l|l|}
\hline
Способ компиляции & Параметр	& Время работы & Ошибка \\
\hline
Kotlin (статическая типизация)              &  100  &   0.668 & ± 0.026 \\
Kotlin (динамическая типизация)             &  100  &   1.244 & ± 0.002 \\
Kotlin (статическая типизация)              &  500  &   2.924 & ± 0.023 \\
Groovy (статическая типизация)              &  100  &   3.830 & ± 0.010 \\
Kotlin (статическая типизация)              & 1500  &   9.918 & ± 0.134 \\
Groovy (invokedynamic)                      &  100  &  10.393 & ± 0.141 \\
Kotlin (динамическая типизация)             &  500  &  14.121 & ± 0.024 \\
Groovy (динамическая типизация)             &  100  &  15.537 & ± 0.051 \\
Groovy (статическая типизация)              &  500  &  27.312 & ± 0.089 \\
Kotlin (динамическая типизация)             & 1500  &  44.486 & ± 0.492 \\
Groovy (invokedynamic)                      &  500  &  53.867 & ± 0.096 \\
Groovy (динамическая типизация)             &  500  &  79.068 & ± 0.316 \\
Groovy (статическая типизация)              & 1500  &  87.638 & ± 0.740 \\
Groovy (invokedynamic)                      & 1500  & 160.532 & ± 2.501 \\
Groovy (динамическая типизация)             & 1500  & 238.856 & ± 0.578 \\
\hline
\end{tabular}
\end{center}
\end{table} 

В таблице \ref{tab:zFunctionBenchResults}, мы видим, что все решения языка Kotlin обыгрывают все решения языка Groovy.

\subsubsection{Быстрое Преобразование Фурье}

Быстрое преобразование Фурье --- алгоритм быстрого вычисления дискретного преобразования Фурье, которое широко используется в области цифровой обработки сигналов. Подробно о реализации алгоритма описано в \cite{algo:dasgypta2014algo}.

\begin{table}[h]
\caption{\label{tab:fftResults}Результаты теста: Быстрое преобразование Фурье}
\begin{center}
\begin{tabular}{|l|l|l|l|}
\hline
Способ компиляции & Параметр	& Время работы & Ошибка \\
\hline
Kotlin (статическая типизация)           &  8 &   1.155 & ± 0.004 \\
Kotlin (динамическая типизация)          &  8 &   1.310 & ± 0.003 \\
Kotlin (статическая типизация)           & 16 &   2.926 & ± 0.010 \\
Kotlin (динамическая типизация)          & 16 &   3.327 & ± 0.014 \\
Kotlin (статическая типизация)           & 32 &   6.178 & ± 0.015 \\
Kotlin (динамическая типизация)          & 32 &   7.023 & ± 0.021 \\
Groovy (invokedynamic)                   &  8 &   7.767 & ± 0.104 \\
Groovy (статическая типизация)           &  8 &   9.180 & ± 0.041 \\
Kotlin (статическая типизация)           & 64 &  12.713 & ± 0.037 \\
Kotlin (динамическая типизация)          & 64 &  15.175 & ± 0.069 \\
Groovy (динамическая типизация)          &  8 &  15.671 & ± 0.043 \\
Groovy (статическая типизация)           & 16 &  17.078 & ± 0.136 \\
Groovy (invokedynamic)                   & 16 &  18.934 & ± 0.290 \\
Groovy (статическая типизация)           & 32 &  34.508 & ± 0.194 \\
Groovy (динамическая типизация)          & 16 &  40.740 & ± 0.741 \\
Groovy (invokedynamic)                   & 32 &  43.490 & ± 0.561 \\
Groovy (статическая типизация)           & 64 &  73.309 & ± 0.623 \\
Groovy (invokedynamic)                   & 64 &  95.854 & ± 0.266 \\
Groovy (динамическая типизация)          & 32 &  96.033 & ± 0.621 \\
Groovy (динамическая типизация)          & 64 & 219.815 & ± 1.664 \\
\hline
\end{tabular}
\end{center}
\end{table} 

Рассмотрев таблицу \ref{tab:fftResults}, мы можем сделать вывод о том, что динамическое решение на языке Kotlin, обыгрывает все решения на языке Groovy. Важно заметить, что статическое и динамическое решения на языке Kotlin, отличаются не сильно.


\subsubsection{Разрешение перегрузок методов}

Одним из важных процессов при выполнении динамического кода является выбор нужной перегрузки метода. Для определения лучшей перегрузки, обычно необходимо произвести много действий во время выполнения кода --- перебрать все методы и определить наиболее подходящий из них. Ввиду большого количества действий, определение перегрузок становится критически влияющим на производительность фактором.

\begin{table}[h]
\caption{\label{tab:overloadsResults}Результаты теста: Разрешение перегрузок методов}
\begin{center}
\begin{tabular}{|l|p{1,5cm}|p{1,5cm}|p{1,5cm}|p{1,5cm}|l|}
\hline
Способ компиляции & Число перегрузок &  Общее число аргументов & Число аргументов по умолчанию & Время работы & Ошибка \\
\hline
Kotlin (статическая типизация)  & 0 & 0 & 0                 & 0.002 & ±  0.001 \\
Kotlin (динамическая типизация) & 0 & 0 & 0                 & 0.002 & ±  0.001 \\
Groovy (статическая типизация)  & 0 & 0 & 0                 & 0.004 & ±  0.001 \\
Groovy (invokedynamic)          & 0 & 0 & 0                 & 0.005 & ±  0.001 \\
Groovy (динамическая типизация) & 0 & 0 & 0                 & 0.017 & ±  0.001 \\
Kotlin (динамическая типизация) & 3 & 3 & 0                 & 0.029 & ±  0.001 \\
Kotlin (статическая типизация)  & 3 & 3 & 0                 & 0.030 & ±  0.001 \\
Groovy (статическая типизация)  & 3 & 3 & 0                 & 0.042 & ±  0.001 \\
Kotlin (динамическая типизация) & 5 & 5 & 0                 & 0.059 & ±  0.001 \\
Kotlin (динамическая типизация) & 10 & 5 & 0                & 0.061 & ±  0.001 \\
Kotlin (статическая типизация)  & 5 & 5 & 0                 & 0.073 & ±  0.001 \\
Kotlin (статическая типизация)  & 10 & 5 & 0                & 0.076 & ±  0.001 \\
Kotlin (динамическая типизация) & 1 & 5 & 3                 & 0.082 & ±  0.001 \\
Groovy (invokedynamic)          & 3 & 3 & 0                 & 0.083 & ±  0.001 \\
Groovy (динамическая типизация) & 3 & 3 & 0                 & 0.087 & ±  0.001 \\
Kotlin (статическая типизация)  & 1 & 5 & 3                 & 0.088 & ±  0.001 \\
Groovy (статическая типизация)  & 10 & 5 & 0                & 0.114 & ±  0.001 \\
Groovy (статическая типизация)  & 5 & 5 & 0                 & 0.120 & ±  0.003 \\
Groovy (статическая типизация)  & 1 & 5 & 3                 & 0.148 & ±  0.001 \\
Groovy (invokedynamic)          & 5 & 5 & 0                 & 0.148 & ±  0.004 \\
Groovy (invokedynamic)          & 10 & 5 & 0                & 0.150 & ±  0.001 \\
Groovy (динамическая типизация) & 10 & 5 & 0                & 0.182 & ±  0.001 \\
Groovy (invokedynamic)          & 1 & 5 & 3                 & 0.185 & ±  0.001 \\
Groovy (динамическая типизация) & 5 & 5 & 0                 & 0.190 & ±  0.003 \\
Groovy (динамическая типизация) & 1 & 5 & 3                 & 0.196 & ±  0.001 \\
\hline
\end{tabular}
\end{center}
\end{table} 

Мы будем замерять время выполнения методов, у которых различное число перегрузок с разным количеством аргументов. Результаты можно наблюдать в таблице  \ref{tab:overloadsResults}. Мы можем сделать вывод о том, что динамическое решение на языке Kotlin, обыгрывает все решения на языке Groovy. Статическое и динамическое решения на языке Kotlin также отличаются не сильно.


\subsection{Анализ результатов}

Посмотрев на результаты работы всех тестов, мы можем сделать вывод, что представленное динамическое расширение языка Kotlin обыгрывает динамическое расширение языка Groovy. Однако, в некоторых тестах наблюдается ухудшение производительности динамического решения Kotlin, по сравнению со статическим решением, обладающее хуже чем линейной зависимостью. 