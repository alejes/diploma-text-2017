\section{Измерения производительности}

Одним из важных вопросов при использовании динамического кода является его производительность. При статической типизации множество проверок и вычислений происходят во время компиляции, тогда как при динамической типизации их приходится производить во время выполнения. Такие проверки могут сильно сказываться на времени работы программы.

\subsection{Особенности измерения производительности на Java платформе}

Важным фактором в любом измерении является степень доверия результату. Код, предназначенный для Java платформы, запускается при помощи виртуальной машины, поэтому нам необходимо учитывать её особенности. Во время выполнения, Java машина часть байт-кода может интерпретировать, выполняя инструкцию за инструкцией, а часть --- компилировать в машинный код. Машинный код выполняется быстрее чем интерпретируемый, однако требует время на свою генерацию. Во время работы, Java машина накапливает статистику по выполняемому коду, на основании которой, она может решать каким способом выполнять каждый участок кода и производить различные оптимизации. Часто, чтобы позволить JVM накопить статистическую информацию, перед замером выполняют несколько, так называемых <<разогревочных>>, запусков.

С накоплением достаточного количество статистики, возникает ещё одна проблема. Часть кода может быть удалена, потому что Java машина посчитает что этот код никак не используется и не влияет на результат работы программы. Также, если во время выполнения станет ясно что результат работы некоторых методов не зависит от внешних факторов, их вызов быть заменён на результат их вычисления. Выполнение замеров производительности на оптимизированном коде даёт ложную картину о скорости работы программы.

Во время выполнения <<разогревочных>> запусков, виртуальная машина Java также накапливает информацию об используемой памяти. На основании этой информации, JVM может выделить для себя большее или меньшее количество памяти. Если JVM не хватает свободной памяти, она может запустить процедуру \textit{сборки мусора} --- процесс поиска и удаления объектов, которые ещё лежат в памяти, но уже не нужны для выполнения программы. Сама процедура сборки мусора может занимать достаточно внушительное время, серьёзно влияя на время работы замеряемого участка кода.

Для повышения точности показателей, при выполнении замеров времени работы программы, рекомендуется отключать сторонние приложения. Ввиду особенности обеспечения планирования процессов в многозадачных системах, отключая приложения мы можем уменьшить влияние фактора того, что планировщик имеет возможность снимать процесс JVM с выполнения.

Одним из популярных способов уменьшить количество проблем при измерениях написанного для JVM платформы кода, является использованием специального программного инструмента --- JMH \cite{java:jmh}. Данный программный инструмент, путём передачи ему определённых параметров, самостоятельно обеспечивает требуемое количество <<разогревочных>> запусков. В рамках каждого из основных запусков, каждый тест производительности запускается несколько раз, после чего вычисляется среднее время работы в рамках этого запуска. Результаты всех запусков представляются как выборка из нормального распределения, с неизвестной дисперсией. По полученной выборке можно рассчитать различные характеристики случайной величины, например математическое ожидание и доверительный интервал.

    Для того чтобы избежать удаления неиспользуемого кода, JMH предоставляет специальный объект типа \textit{Blackhole}. Передача результата в этот объект позволяет избежать случая, при котором Java машина считает что результат операции ни на что не влияет, и не выполняет часть кода.

\subsection{Окружение при проведении измерений производительности}

\begin{itemize}
    \item \textbf{Операционная система:} Linux version 4.4.0-71-generic (buildd\at lcy01-05) (gcc version 5.4.0 20160609 (Ubuntu 5.4.0-6ubuntu1~16.04.4) ) \#92-Ubuntu SMP Fri Mar 24 12:59:01 UTC 2017.
    \item \textbf{Центральный процессор:}  Intel(R) Core(TM) i7-6700 CPU \at 3.40GHz.
    \item \textbf{Версия JVM:}  Java HotSpot(TM) 64-Bit Server VM (build 25.121-b13, mixed mode).
    \item \textbf{Версия JRE:}  Java(TM) SE Runtime Environment (build 1.8.0\_121-b13).
\end{itemize}


\subsection{Рассмотренные тесты производительности}

В рамках данной работы был разработан набор тестов производительности, для оценки практичности решения. Будут сравниваться решения на языках Kotlin и Groovy. В языке Groovy, начиная с версии 2.0, появилась поддержка инструкции \textit{invokedynamic} JVM платформы \cite{groovy:invokeDynamicSupport}. Есть измерения, что в некоторых случаях, Groovy код, скомпилированный с поддержкой данной инструкции, работает быстрее \cite{groovy:indyTest1}.
В каждом тесте производится сравнение одинакового кода, переписанного с учётом особенностей каждого языка или способа компиляции. В качестве целевых платформ, для тестирования производительности, использовались следующие:

\begin{itemize}
    \item Kotlin (статическая типизация, версия 1.1 rc) 
    \item Kotlin (максимально возможное число объектов помечено типом \textit{dynamic}, на основе версии 1.1 rc)
    \item Groovy (версия 2.4.5)
    \item Groovy Invoke Dynamic (версия 2.4.5)
    \item Groovy (с аннотацией CompileStatic) (версия 2.4.5)
\end{itemize}


Для поддержания объективности, каждый тест производился на всех целевых платформах, при различных размерах входных данных. Исходный код тестов для всех платформ, можно найти в репозитории \cite{github:myBenchs}. При анализе результатов, основное внимание мы будем обращать на следующее:

\begin{itemize}
    \item Относительное различие статически и динамически типизированного кода.
    \item Сравнение скорости работы динамической типизированного кода на языке Kotlin, с динамически типизируемым кодом Groovy (при компиляции <<обычным способом>> и с помощью \textit{invokedynamic} инструкции.
\end{itemize}

Для удобства анализа результатов, мы будем сортировать данные по увеличению времени работы. В качестве времени работы, мы будем замерять время выполнения одного запуска теста в секундах. Если в описании теста не указано иного, перед запуском тестов мы не будем проводить <<разогревочных>> итераций. Это сделано для того чтобы исключить кеширование результатов вычисления перегрузок. После этого мы будем запускать код на выполнение один раз в рамках <<основных>> итераций. Такой процесс мы повторим 20 раз, используя каждый раз новый процесс java. На основании всех результатов <<основных>> итераций, мы будем вычислять ошибку --- максимальное замеченное отклонение, относительно посчитанного времени работы. Также были проведены замеры времени работы <<разогретого>> кода, в котором происходил запуск 20 <<разогревочных>> итераций перед выполнением 20 <<основных>>. Результаты таких замеров были отличались мультипликативно от результатов описанных в работе, однако относительный порядок скорости работы был аналогичный.

\subsubsection{Вычисление чисел Фибоначчи}

Числа Фибоначчи представляют собой возрастающую последованность, в которой первые два элемента равны 1, а следующие равны сумме двух предыдущих \cite{math:vilenkin1969Combinatorics}. Данный тест реализован в рекурсивном варианте решения, в котором расчёт результирующего значения для \textit{i}-го элемента, выполняется путём запуска вычисления алгоритма от \textit{i-1}-го, и \textit{i-2}-го элемента, без выполнения каких-то техник запоминания промежуточных результатов.


\begin{figure}
\caption{\label{graph:fibBenchResults}Результаты теста: Числа Фибоначчи. По данным таблицы \ref{tab:fibBenchResults}.}
\begin{tikzpicture}
\begin{semilogyaxis}[
    legend pos = north west, 
    legend cell align = left,
    %height = 0.6\paperheight, 
	width = 0.75\paperwidth,
	xlabel = Номер элемента в последовательности,
	ylabel = Время работы (мкс)
]
\legend{ 
    Groovy (динамическая типизация),
	Groovy (invokedynamic),
	Kotlin (динамическая типизация),
	Groovy (статическая типизация),
	Kotlin (статическая типизация)
};
\addplot coordinates {
	(10,     2.657) (15,    34.054) (20,   380.277) (25,  4196.605) (30, 46693.945)
};
\addplot coordinates {
	(10,     1.303) (15,    14.101) (20,   160.403) (25,  1706.428) (30, 19001.554)
};
\addplot coordinates {
    (10,     0.460) (15,     5.972) (20,    66.279) (25,   734.782) (30,  8235.996)
};
\addplot coordinates {
	(10,     0.177) (15,     1.932) (20,    21.484) (25,   237.520) (30,  2704.712)
};
\addplot coordinates {
    (10,    0.169) (15,    1.834) (20,   20.391) (25,  225.264) (30, 2581.537)
};

\end{semilogyaxis}
\end{tikzpicture}
\end{figure}


Результаты измерений представлены на рисунке \ref{graph:fibBenchResults}. Статические решения языков Groovy и Kotlin показывают примерно одинаковую производительность. Однако, статическое решение Groovy чуть-чуть медленнее, потому что порождаемый им класс в конструкторе  производит набор операций, необходимых для реализации интерфейса \textit{groovy.lang.GroovyObject}.

Традиционное динамическое решение Groovy медленнее чем решение с использованием инструкции \textit{invokedynamic}. Это можно объяснить тем, что во втором решении, в начале работы, происходит связывание каждой точки вызова с целевой ссылкой на метод. Так как во время работы программы не меняются типы приходящие на каждую точку вызова, каждый вызов будет происходить с использованием сохранённых в JVM значений. Это будет оптимизироваться, и происходить быстрее чем в традиционном решении.

Можно заметить, что разработанное динамическое решение Kotlin оказалось быстрее чем решение Groovy (invokedynamic), несмотря на то, что они оба используют инструкцию \textit{invokedynamic}. Это можно объяснить тем, что описанное в настоящей работе решение эффективней реализует операции над  стандартными типами. Решение Groovy для обеспечения корректности операции сложения двух чисел использует методы класса \textit{org.codehaus.groovy.runtime.dgmimpl.NumberNumberPlus}, который делает множество тяжеловесных операций, таких как например \textit{instanceof}.

Важным является факт того, что сложность динамического решения не ухудшается с ростом параметра. Решение Groovy (invokedynamic) на протяжении всех измерений, хуже своего статического аналога примерно в 7.26 раз, а решение Kotlin --- в 3.13 раз.

\subsubsection{Возведение матрицы в квадрат}

Перемножение матриц является классической задачей для тестирования производительности. В рамках нашей задачи нету необходимости вдаваться в тонкости оптимизаций размещения матрицы в памяти. Мы будем возводить в матрицу, хранящуюся как массив массивов чисел, в квадрат, по стандартной формуле произведения матриц, описанной например в \cite{book:KryakvinVadimDLinAlgebra}. 



\begin{figure}
\caption{\label{graph:matrixSquareBenchResults}Результаты теста: Возведение матрицы в квадрат. По данным таблицы \ref{tab:matrixSquareBenchResults}.}
\begin{tikzpicture}
\begin{axis}[
    legend pos = north west, 
    legend cell align = left,
    %height = 0.6\paperheight, 
	width = 0.75\paperwidth,
	xlabel = Порядок матрицы,
	ylabel = Время работы (мкс)
]
\legend{ 
	Groovy (invokedynamic),
	Groovy (динамическая типизация),
	Groovy (статическая типизация),
	Kotlin (динамическая типизация),
	Kotlin (статическая типизация)
};
\addplot coordinates {
	(10,  211.729) (15,  637.817) (20, 1416.187) (25, 2493.244) (30, 4254.972)
};
\addplot coordinates {
	(10,  135.590) (15,  427.245) (20, 1024.478) (25, 2307.156) (30, 3782.256)
};
\addplot coordinates {
	(10,  36.447) (15,  78.785) (20, 188.443) (25, 353.132) (30, 637.911)
};

\addplot coordinates {
    (10,  29.745) (15,  79.319) (20, 203.864) (25, 360.012) (30, 607.052)
};
\addplot coordinates {
    (10,  12.299) (15,  38.676) (20,  90.442) (25, 180.148) (30, 309.295)
};

\end{axis}
\end{tikzpicture}
\end{figure}


Согласно рисунку \ref{graph:matrixSquareBenchResults} мы видим, что решение рассмотренное в настоящей работе обыгрывает динамические решения в языке Groovy. Интересным является факт того, что динамическое решение Kotlin примерно сравнимо по производительности со статическим решением Groovy. Это можно объяснить тем, что в этом случае Groovy генерирует достаточно сложный байт-код. По сравнению со статическим решением Kotlin, он использует достаточно много таких операций как:

\begin{itemize}
    \item \textit{ScriptBytecodeAdapter.castToType} --- используется для приведения типов, с учётом их особенностей в языке Groovy.
    \item \textit{NumberNumberMultiply.multiply} и \textit{NumberNumberPlus.plus} --- используются для осуществления операций сложения и умножения. В статически типизированном коде Kotlin, вместо них выполняются быстрые байт-код инструкции \textit{imul} и \textit{iadd} соответственно.
    \item \textit{IntRange} --- используется для итерирования по элементам матрицы. В то время как в языке Kotlin, используется увеличение индексной переменной и её сравнение порядком матрицы.
\end{itemize}

Важным является факт того, что сложность динамического решения языка Kotlin не ухудшается с ростом порядка матрицы. Оно хуже своего статического аналога примерно в 2.13 раз. Решение Groovy (invokedynamic) хуже своего статического аналога примерно в 7.03 раз.

\subsubsection{Z-функция}


Z-функция от какой-то строки --- массив совпадающий с ней по длине, в которой i-ый элемент, совпадает с числом символов, которые начиная с i-ой позиции, совпадают с первыми символами данной строки. Z-функция помогает решать множество задач связанных с поиском подстрок в строке.
Детали её реализации подробно описаны например в \cite{algo:gusfield1997algorithms}.


\begin{figure}
\caption{\label{graph:zFunctionBenchResults}Результаты теста: Z-функция. По данным таблицы \ref{tab:zFunctionBenchResults}.}
\begin{tikzpicture}
\begin{axis}[
    legend pos = north west, 
    legend cell align = left,
    %height = 0.6\paperheight, 
	width = 0.75\paperwidth,
	xlabel = Длина строки,
	ylabel = Время работы (мкс)
]
\legend{ 
    Groovy (invokedynamic),
    Groovy (динамическая типизация),
	Groovy (статическая типизация),
	Kotlin (динамическая типизация),
	Kotlin (статическая типизация)
};
\addplot coordinates {
	( 100,  20.357) ( 500, 151.746) (1000, 259.352) (1250, 353.048) (1500, 479.484)
};
\addplot coordinates {
	( 100,  24.929) ( 500, 135.307) (1000, 287.103) (1250, 339.957) (1500, 413.121)
};
\addplot coordinates {
	( 100,   4.878) ( 500,  41.122) (1000,  79.720) (1250,  98.272) (1500, 118.800)
};
\addplot coordinates {
    ( 100, 1.666) ( 500, 23.708) (1000, 45.962) (1250, 58.214) (1500, 76.108)
};
\addplot coordinates {
    ( 100,  0.750) ( 500,  3.122) (1000,  7.253) (1250,  8.347) (1500, 10.636)
};
    
\end{axis}
\end{tikzpicture}
\end{figure}

По рисунку \ref{graph:zFunctionBenchResults}, мы видим, что все решения языка Kotlin обыгрывают все решения языка Groovy. Стоит заметить, что динамическое решение Kotlin обыгрывает в среднем в 1.92 раз статическое решение Groovy. Это во многом происходит благодаря тому, что Groovy довольно большой объём кода выполняет для простых операций.

\subsubsection{Быстрое Преобразование Фурье}

Быстрое преобразование Фурье --- алгоритм быстрого вычисления дискретного преобразования Фурье, которое широко используется в области цифровой обработки сигналов. Подробно о реализации алгоритма описано в \cite{algo:dasgypta2014algo}.



\begin{figure}
\caption{\label{graph:fftResults}Результаты теста: Быстрое преобразование Фурье. По данным таблицы \ref{tab:fftResults}.}
\begin{tikzpicture}
\begin{semilogyaxis}[
    legend pos = south east, 
    legend cell align = left,
    %height = 0.6\paperheight, 
	width = 0.75\paperwidth,
	xlabel = Размерность вектора,
	ylabel = Время работы (мкс)
]
\legend{ 
	Groovy (invokedynamic),
	Groovy (динамическая типизация),
	Groovy (статическая типизация),
	Kotlin (динамическая типизация),
	Kotlin (статическая типизация)
};
\addplot coordinates {
	( 8,  258.238) (16,  496.029) (32, 1212.422) (64, 3192.987)
};
\addplot coordinates {
	( 8,  35.283) (16,  88.188) (32, 204.344) (64, 492.665)
};
\addplot coordinates {
	( 8,  18.047) (16,  33.198) (32,  68.408) (64, 143.962)
};
\addplot coordinates {
    ( 8,  2.030) (16,  4.594) (32,  9.918) (64, 21.308)
};
\addplot coordinates {
    ( 8,  1.492) (16,  3.246) (32,  6.816) (64, 14.217)
};
    
\end{semilogyaxis}
\end{tikzpicture}
\end{figure}


Рассмотрев рисунок \ref{graph:fftResults}, мы можем сделать вывод о том, что динамическое решение на языке Kotlin, обыгрывает все решения на языке Groovy. %Важно заметить, что статическое и динамическое решения на языке Kotlin, отличаются не сильно.
Cтоит заметить, что динамическое решение Kotlin в среднем в 7.44 раз быстрее статического решения Groovy.


\subsubsection{Разрешение перегрузок методов}
\label{sec:benchOverloadsResolv}

Одним из важных процессов при выполнении динамического кода является выбор нужной перегрузки метода. Для определения лучшей перегрузки, обычно необходимо произвести много действий во время выполнения кода --- перебрать все методы и определить наиболее подходящий из них. Ввиду большого количества действий, определение перегрузок становится критически влияющим на производительность фактором.

Перед запуском всех тестов данного раздела мы будем проводить 20 <<разогревочных>> итераций. После этого мы будем запускать код на выполнение ещё 20 раз в рамках <<основных>> итераций.

Мы будем замерять время выполнения методов, у которых различное число перегрузок с разным количеством аргументов. Результаты можно наблюдать в таблице  \ref{tab:overloadsResults}. Мы можем сделать вывод о том, что динамическое решение на языке Kotlin, обыгрывает все решения на языке Groovy. Статическое и динамическое решения на языке Kotlin также отличаются не сильно.

\subsubsection{Разрешение перегрузок на списке динамических объектов}
\label{sec:listDynObjects}

Произведём тест, аналогичный рассмотренному в разделе \ref{sec:benchOverloadsResolv}, только теперь возьмём список из 1000 объектов типа \textit{int} и 1000 объектов типа \textit{String}. Этот список мы случайно перемешаем. Каждый объект, который мы достанем из списка, будет участовать в качестве одного из аргументов перегруженного метода. Все остальные аргументы будут фиксированы. Причём, при комбинации фиксированных аргументов с типом \textit{int} и с типом \textit{String} будут подходить разные перегрузки метода. Заметим, что данный тест возможен только при динамической типизации, поэтому мы его будем воспроизводить не на всех целевых платформах.

Полученные результаты представлены в таблице \ref{tab:listOvrlds}.

\subsubsection{Параллельное разрешение перегрузок на списке динамических объектов}

Интересным будет воспроизведение ситуации, описанной в разделе \ref{sec:listDynObjects}, в многопоточной среде. Запустим тот же самый тест параллельно в 8 потоков.

Полученные результаты представлены в таблице \ref{tab:parallListDynObjects}.

\subsection{Анализ результатов}

Посмотрев на результаты работы всех тестов, мы можем сделать вывод, что представленное динамическое расширение языка Kotlin обыгрывает динамическое расширение языка Groovy. Однако, в некоторых тестах наблюдается ухудшение производительности динамического решения Kotlin, по сравнению со статическим решением, обладающее хуже чем линейной зависимостью. 