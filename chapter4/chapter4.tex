\section{Измерения производительности}

Одним из важных критериев использования динамического кода является его производительность. Коль скоро, множество проверок и вычислений, который делает статически типизированный код во время компиляции, динамическому коду приходится производить во время выполнения, это сильно сказывается на времени его работы.

\subsection{Особенности измерения производительности на Java платформе}

Важным фактором в любом измерении является степень доверия результату. Код, предназначенный для Java платформы, запускается при помощи виртуальной машины, поэтому нам необходимо учитывать её особенности. Во время выполнения, Java машина может часть байт-кода интерпретировать, выполняя инструкцию за инструкцией, а часть  компилировать в машинный код. Машинный код выполняется быстрее чем интерпретируемый, однако требует время на свою генерацию. Во время работы, Java машина накапливает статистику по выполняемому коду, на основании которой она может решать каким способом выполнять каждый участок кода, а также производить различные оптимизации. Часто, чтобы позволить JVM накопить статистическую информацию, перед замером, выполняют несколько, так называемых <<разогревочных>> запусков.

С накоплением достаточного количество статистики, возникает следующая проблема. Часть кода может быть удалено, потому что Java машина посчитает что он никак не используется и не влияет на результат работы программы. Также, вызов некоторых методов может быть заменён на результат их вычисления, если во время выполнения станет ясно что результат не зависит от внешнего окружения. Выполнения замеров производительности на таком оптимизированном коде, даёт ложную картину о скорости работы программы.

Во время выполнения <<разогревочных>> запусков, виртуальная машина Java также накапливает информацию об используемой памяти, и может выделить для себя её большее количество. Если JVM не хватает свободной памяти, то она может запустить процедуру \textit{сборки мусора} --- поиска и удаления объектов, которые ещё лежат в памяти, но уже не нужны для выполнения программы. Сама процедура сборки мусора может занимать достаточно внушительное время, и серьёзно повлиять на время работы замеряемого участка кода.

Для повышения точности показателей, при выполнении замеров времени работы программы, рекомендуется отключать сторонние приложения. Ввиду особенности обеспечения планирования процессов в многозадачных системах, тем самым мы можем уменьшить влияние того фактора, что планировщик может вытеснить процесс JVM с выполнения.

Одним из популярных способов, уменьшить количество проблем при измерениях кода, написанного для JVM платформы, является использованием специального программного инструмента --- JMH \cite{java:jmh}. Данный программный интерфейс, путём передачи ему определённых параметров, самостоятельно обеспечивает требуемое количество <<разогревочных>> запусков. В рамках каждого из основных запусков, каждый тест производительности запускается несколько раз, и вычисляется среднее время работы в рамках этого запуска. Результаты всех запусков представляются как выборка из нормального распределения, с неизвестной дисперсией. По полученной выборке можно рассчитать различные характеристики случайной величины, например математическое ожидание и доверительный интервал.

Для того чтобы избежать удаления не используемого кода, JMH предоставляет специальный объект типа \textit{Blackhole}. Передача результата в этот объект, позволяет избежать случая, при котором Java машина считает что результат операции ни на что не влияет, и не выполняет часть кода.

\subsection{Окружение при проведении измерений производительности}

\begin{itemize}
    \item \textbf{Операционная система:} Linux version 4.4.0-71-generic (buildd\at lcy01-05) (gcc version 5.4.0 20160609 (Ubuntu 5.4.0-6ubuntu1~16.04.4) ) \#92-Ubuntu SMP Fri Mar 24 12:59:01 UTC 2017.
    \item \textbf{Центральный процессор:}  Intel(R) Core(TM) i7-6700 CPU \at 3.40GHz.
    \item \textbf{Версия JVM:}  Java HotSpot(TM) 64-Bit Server VM (build 25.121-b13, mixed mode).
    \item \textbf{Версия JRE:}  Java(TM) SE Runtime Environment (build 1.8.0\_121-b13).
\end{itemize}


\subsection{Рассмотренные тесты производительности}

В рамках данной работы был разработан набор тестов производительности, для оценки практичности решения. В языке Groovy, начиная с версии 2.0, появилась поддержка инструкции \textit{invokedynamic} JVM платформы \cite{groovy:invokeDynamicSupport}. Есть измерения, что в некоторых случаях, Groovy код, скомпилированный с поддержкой данной инструкции, работает быстрее \cite{groovy:indyTest1}.
В каждом тесте производится сравнение одинакового кода, переписанного с учётом особенностей каждого языка или способа компиляции. В качестве целевых платформ, для тестирования производительности, использовались следующие:

\begin{itemize}
    \item Kotlin (статическая типизация, версия 1.1 rc) 
    \item Kotlin (максимально возможное число объектов помечено типом \textit{dynamic}, на основе версии 1.1 rc)
    \item Groovy (версия 2.4.5)
    \item Groovy Invoke Dynamic (версия 2.4.5)
    \item Groovy (с аннотацией \at CompileStatic) (версия 2.4.5)
\end{itemize}


Для поддержания объективности, каждый тест производился на всех целевых платформах, при различных размерах входных данных. Исходный код тестов для всех платформ, можно найти в репозитории \cite{github:myBenchs}. При анализе результатов, основное внимание будем обращать на следующие вещи:

\begin{itemize}
    \item Относительное различие статически и динамически типизированного кода.
    \item Сравнение скорости работы динамической типизированного кода на языке Kotlin, с динамически типизируемым кодом Groovy (при компиляции <<обычным способом>> и с помощью \textit{invokedynamic} инструкции.
\end{itemize}

Для удобства анализа результатов, мы будем сортировать данные по увеличению времени работы. В качестве времени работы мы будем замерять время выполнения одного запуска теста в секундах. Перед запуском тестов мы будем проводить 20 <<разогревочных>> итераций. После этого мы будем запускать код на выполнение ещё 20 раз. На основании всех результатов <<основных>> итераций, мы будем вычислять ошибку --- максимальное замеченное отклонение, относительно посчитанного времени работы.

\subsubsection{Вычисление чисел Фибоначчи}

Числа Фибоначчи представляют собой возрастающую последованность, в которой первые два элемента равны 1, а следующие равны сумме двух предыдущих \cite{math:vilenkin1969Combinatorics}. Данные тест реализован в рекурсивном варианте решения, в котором расчёт результирующего значения для \textit{i}-го элемента, выполняется путём запуска вычисления алгоритма от \textit{i-1}-го, и \textit{i-2}-го элемента, без выполнения каких-то техник запоминания промежуточных результатов.

\begin{table}[h]
\caption{\label{tab:fibBenchResults}Результаты теста: Числа Фибоначчи}
\begin{center}
\begin{tabular}{|c|l|l|l|}
\hline
Способ компиляции & Параметр & Время работы & Ошибка \\
\hline
Kotlin (статическая типизация) & 10 & 0.169 & ±0.001 \\
Groovy (статическая типизация) & 10 & 0.169 & ±0.001 \\
Kotlin (динамическая типизация) & 10 & 0.416 & ±0.001 \\
Groovy (invokedynamic) & 10 & 0.966 & ±0.001 \\
Groovy (динамическая типизация) & 10 & 2.068 & ±0.001 \\
Kotlin (статическая типизация) & 20 & 20.332 & ±0.017 \\
Groovy (статическая типизация) & 20 & 21.409 & ±0.010 \\
Kotlin (динамическая типизация) & 20 & 61.207 & ±0.429 \\
Groovy (invokedynamic) & 20 & 117.719 & ±0.165 \\
Groovy (динамическая типизация) & 20 & 329.021 & ±3.364 \\
Kotlin (статическая типизация) & 30 & 2504.207 & ±4.087 \\
Groovy (статическая типизация) & 30 & 2632.423 & ±1.098 \\
Kotlin (динамическая типизация) & 30 & 7967.828 & ±252.977 \\
Groovy (invokedynamic) & 30 & 14487.808 & ±20.088 \\
Groovy (динамическая типизация) & 30 & 39568.232 & ±1359.947 \\
\hline
\end{tabular}
\end{center}
\end{table} 


Согласно таблице \ref{tab:fibBenchResults} мы видим, что решение рассмотренное в настоящей работе обыгрывает динамические решения в языке Groovy. По сравнению с типизированным решением, динамическое проигрывает примерно в три раза.


\subsubsection{Возведение матрицы в квадрат}

Перемножение матриц является классической задачей для тестирования производительности. В рамках нашей задачи нету необходимости вдаваться в тонкости оптимизаций размещения матрицы в памяти. Мы будем возводить в матрицу, хранящуюся как массив массивов чисел, в квадрат, по стандартной формуле произведения матриц, описанной например в \cite{book:KryakvinVadimDLinAlgebra}. 

\begin{table}[h]
\caption{\label{tab:matrixSquareBenchResults}Результаты теста: Возведение матрицы в квадрат}
\begin{center}
\begin{tabular}{|c|l|l|l|}
\hline
Способ компиляции & Параметр	& Время работы & Ошибка \\
\hline
Kotlin (статическая типизация)   &   10 &    11.084 & ±  0.043\\
Kotlin (динамическая типизация)  &   10 &    18.233 & ±  0.060\\
Groovy (динамическая типизация)  &   10 &    18.973 & ±  0.064\\
Groovy (статическая типизация)   &   10 &    78.352 & ±  0.270\\
Groovy (invokedynamic)           &   10 &    78.883 & ±  0.191\\
Kotlin (статическая типизация)   &   20 &    85.836 & ±  0.267\\
Kotlin (динамическая типизация)  &   20 &   126.976 & ±  0.441\\
Groovy (динамическая типизация)  &   20 &   205.031 & ±  0.737\\
Kotlin (статическая типизация)   &   30 &   294.722 & ±  0.992\\
Kotlin (динамическая типизация)  &   30 &   436.604 & ± 12.506\\
Groovy (динамическая типизация)  &   30 &   465.745 & ±  1.279\\
Groovy (invokedynamic)           &   20 &   602.936 & ±  2.066\\
Groovy (статическая типизация)   &   20 &   604.011 & ±  1.644\\
Groovy (invokedynamic)           &   30 &  1957.245 & ±  5.707\\
Groovy (статическая типизация)   &   30 &  2462.848 & ±  7.843\\
\hline
\end{tabular}
\end{center}
\end{table} 


Согласно таблице \ref{tab:fibBenchResults} мы видим, что решение рассмотренное в настоящей работе обыгрывает динамические решения в языке Groovy.

\subsubsection{Z-функция}


Z-функция от какой-то строки --- массив совпадающий с ней по длине, в которой i-ый элемент, совпадает с числом символов, которые начиная с i-ой позиции, совпадают с первыми символами данной строки. Z-функция помогает решать множество задач связанных с поиском подстрок в строке.
Детали её реализации подробно описаны например в \cite{algo:gusfield1997algorithms}.

\begin{table}[h]
\caption{\label{tab:zFunctionBenchResults}Результаты теста: Z-функция}
\begin{center}
\begin{tabular}{|c|l|l|l|}
\hline
Способ компиляции & Параметр	& Время работы & Ошибка \\
\hline
Kotlin (динамическая типизация) & 1000 & 0 & 0 \\
\hline
\end{tabular}
\end{center}
\end{table} 

\subsubsection{Быстрое Преобразование Фурье}

Быстрое преобразование Фурье --- алгоритм быстрого вычисления дискретного преобразования Фурье, которое широко используется в области цифровой обработки сигналов. Подробно о реализации алгоритма описано в \cite{algo:dasgypta2014algo}.

\begin{table}[h]
\caption{\label{tab:fftResults}Результаты теста: Быстрое преобразование Фурье}
\begin{center}
\begin{tabular}{|c|l|l|l|}
\hline
Способ компиляции & Параметр	& Время работы & Ошибка \\
\hline
Kotlin (динамическая типизация) & 1000 & 0 & 0 \\
\hline
\end{tabular}
\end{center}
\end{table} 