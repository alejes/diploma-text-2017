\section{Обзор литературы}

Для разработки программного обеспечения часто используют различные методы, которые помогают убедиться что система ведёт себя в соответствии с некоторой спецификацией. Одним из таких методов являются \textit{системы типов}. Согласно \cite{book:pierce2002types}, для них можно дать такое определение:


\begin{definition}
Система типов --- это гибко управляемый синтаксический метод доказательства отсутствия в программе определенных видов поведения при помощи классификации выражений языка по разновидностям вычисляемых ими значений.
\end{definition}

Одним из важных свойств этого определения является упор на классификацию термов, согласно значениям, в которые они могут быть вычислены.

\subsection{Виды типизации в языках программирования}

В зависимости от типизации, языки программирования можно рассматривать как представителей одной из следующих групп.
\begin{itemize}
\itemsep-1mm
\item Языки с статической типизацией (static typing languages).
\item Языки с динамической типизацией (dynamic typing languages).
\item Языки с постепенной типизацией (gradual typing  languages).
\end{itemize}



Языки со статической типизацией отличает связывание переменных, параметров подпрограмм и возвращаемых значений функций с типом в момент объявления, и этот тип нельзя будем изменить позднее. Таким образом, в момент компиляции мы знаем типы всех выражений. Такое знание позволяет нам проводить некоторые оптимизации и проводить некоторый анализ, на основе которого предоставлять пользователю некоторые подсказки в рамках Интегрированной Среды Разработки (ИСР).

В языках с динамической типизацией, связывание происходит в момент присваивания  значения, во время выполнения программы. Причём одна и та же переменная может быть связана с разными типами, в зависимости от логики программы. Рассмотрим следующий пример.

\vskip4pt

\begin{minted}[mathescape,
               linenos,
               numbersep=5pt,
               gobble=2,
               frame=lines,
               framesep=2mm]{csharp}
    class A {
        method1()
    }
    class B {
        method1()
    }

    x.method1()
\end{minted} 

\vskip4pt

%\begin{algorithm}[H]
%\SetAlgoLined
%\DontPrintSemicolon
%\KwData{слово $w={a^{{\delta _1}}}{a^{{\delta _2}}} \ldots {a^{{\delta _k}}}%({\delta _i} \in \{ -1,1\}, k \geqslant 0 )$}
%\KwResult{$G’=(X,V)$ with $V\subseteq U$ such that $G’^{tc}$ is an interval order.}
%\Begin{
%	текущая вершина $\leftarrow$ вершина помеченная символом I\;
%	\For{$i\leftarrow 1$ \KwTo $k$}{
%		\uIf{$\delta_k=1$}{
%			текущая вершина $\leftarrow$ вершина в которую можно придти перейдя %из текущей вершины 	\textit{в направлении, указанном стрелкой} 	
%		}
%		\uElse{
%			текущая вершина $\leftarrow$ вершина в которую можно придти перейдя %из текущей вершины 			в направлении, \textit{противоположном} указанному %стрелкой
%		}
%	}
%}
%\caption{Представление слов как вершин графа циклической группы}
%\end{algorithm}

В зависимости от типа переменной \textit{x}, вызов \textit{x.method1()} может разрешиться в вызов разных методов - из класса A, класса B, или завершиться с ошибкой, если \textit{x} будет другого типа, для которого не определён метод \textit{method1()}. В этом случае мы ограничены в проведении оптимизаций, и ограничены в предоставлении подсказок пользователю в рамках ИСР, потому что в большинстве случаев, до процесса выполнения мы ничего не знаем о типе переменной \textit{x}.

\begin{definition}
    Процесс определения назначения операции, базирующийся на типе или значениях составляющих его выражений называют связыванием.
\end{definition}
Например, назначение вызова метода, основывается на типе его аргументов, и типе объекта, на котором мы вызваем этот метод. Заметим, что связывание выражений, типы которых можно определить во время компиляции, можно тоже провести во время компиляции. Такой процесс называют \textit{статическим связыванием}. С другой стоороны, если типы не всех элементов операции мы можем определить во время компиляции (например часть из них имееет тип \textit{dynamic}), то мы можем вести  речь про \textit{динамическое связывание} \cite{csharp:languageSpecification}.

Постепенная типизация представляет собой систему типов, в которой часть переменных и выражений может быть типизированна, и их корректность проверяется в момент компиляции, а часть может быть не типизированна, и об ошибках типизации в них мы узнаем в момент исполнения. При такой типизации мы можем использовать преимущества статической и динамической типизации. Часть кода мы можем типизировать и верифицировать его в момент компиляции. Также компилятор нам может гарантировать некоторый набор оптимизаций, необходимых для ускорения кода. В то же время, мы можем получить возможность выразить в рамках нашего языка некоторые удобные конструкции или упростить их написание.

\begin{itemize}
    \item В \textbf{eval} - функцию, которая отображает код программы записанный в строковом виде, в результат выполнения этого кода в текущем окружении.
    \item Упрощается реализация предметно-ориентированных языков - языков упрощающих решение прикладных задания в некоторой специализированной области.
    \item Удобная работа с объектной моделью документа (ОМД) - программным интерфейсом, позволяющим унифицированно работать с HTML-, XHTML-, и XML-документами.
\end{itemize}

Возможны два подхода к постепенной типизации. У нас изначально может быть статически типизированный язык, и в нём, для некоторых выражений мы будем помечать, что их тип будет известен только в момент выполнения. Таким путём пошли языки C{\#}, Dart, Perl 6. Противоположным подходом является ситуация, что у нас есть динамически типизированный язык, и мы к нему добавляем некоторые ограничения на типы. Эти ограничения могут проверяться во время выполнения, или в момент компиляции, в зависимости от реализации языка программирования. Таким путём пошли языки PHP 7, TypeScript, Python.

При реализации постепенной типизации, обычно используется специальный тип, называемый \textit{dynamic}, для представления статически неизвестного типа. Также у нас изменяется понятие эквивалентности типов, добавлением отношения \textit{согласованности}, которое говорит что динамический тип согласован с любым другим. Заметим, что это отношение не транзитивно, иначе из него можно было бы вывести что любой тип согласован с любым другим.


\subsection{Постепенная типизация в языках программирования}

\subsubsection{PHP 7}

PHP является динамическим языком. В его седьмой версии добавили возможность аннотировать возвращаемое значение и аргументы функций скалярными типами int, float, string и bool \cite{wiki:phpScalarTypeHints}. В предыдущих версиях также поддерживалась проверка аргументов на то что они являтся массивом, корректным вызываемым типом, является экземпляром какого-то класса или реализует требуемый интерфейс \cite{wiki:phpTypeHints}.

\begin{minted}[mathescape,
               linenos,
               numbersep=5pt,
               gobble=2,
               frame=lines,
               framesep=2mm]{php}
    <?php        
        function add(int $a, int $b): int {
           return $a + $b;
        }
        var_dump(add(1, 2)); // int(3)
        // floats are truncated by default
        var_dump(add(1.5, 2.5)); // int(3)
 
        //strings convert if there's a number part
        var_dump(add("1", "2")); // int(3)
    ?>
\end{minted}

Все проверки типов происходят во время исполнения, при несоотвествии типов в PHP 5 будет обрабатываться фатальная ошибка, а в PHP 7 будет выбрасываться исключение \textbf{TypeError}.

\subsubsection{Python}
Как и PHP, Python является динамическим языком, и начиная с весрии 3.5, в нём можно аннотировать аргументы и возвращаемое значение \cite{wiki:pythonPep484TypeHints}. В типах можно выражать и какие-то более сложные составные конструкции, например тип суммы типов выглядит так.
\begin{minted}[mathescape,
               linenos,
               numbersep=5pt,
               gobble=2,
               frame=lines,
               framesep=2mm]{python}
    from typing import Union
    
    def handle_employees(e: Union[Employee, Sequence[Employee]]) -> None:
        if isinstance(e, Employee):
            e = [e]
        ...
\end{minted}

Python не производит никаких проверок типов, однако, их можно осуществить при помощи сторонних средств. Например, с помощью статического валидатора типов mypy \cite{python:mypyHomepage} или инструментов входящих в ИСР JetBrains PyCharm \cite{python:PyCharmHomepage}.

\subsubsection{Groovy}

Groovy является динамическим языком. Для обеспечения частичной типизации, в нём есть два механизма. Предположим, у нас есть какой-то код на этом языке.

\begin{minted}[mathescape,
               linenos,
               numbersep=5pt,
               gobble=2,
               frame=lines,
               framesep=2mm]{groovy}
    class A {
        def foo(x) {
            return x + 1
        }
    }
\end{minted}

Мы можем, также как и в предыдущих языках, проаннотировать все его компоненты типами.

\begin{minted}[mathescape,
               linenos,
               numbersep=5pt,
               gobble=2,
               frame=lines,
               framesep=2mm]{groovy}
    class A {
        int foo(int x) {
            return x + 1
        }
    }
\end{minted}

Другим способом является добавление к классу аннотации \textit{@CompileStatic} \cite{groovy:compileStatic}. В проаннотированных таким образом классах, будут осуществлены проверки типов в момент компиляции.



\subsubsection{C{\#}}

    C{\#} является первым представителем языков, которые изначально были статически типизированы. В версии 4.0 в нём добавили возможность помечать некоторые выражения типом \textit{dynamic}. Поведение этого типа, во многом, схоже с поведением типа \textit{object}, являющимся самым общим типом в иерархии наследования. В частности, переменные типа \textit{dynamic}, компилируются в тип \textit{object}. Поэтому, тип  \textit{dynamic} существует только в процессе компиляции, и отсутствует во время выполнения \cite{msdn:dynamicType}. В операциях, которые содержат в своей части выражения помеченные типом \textit{dynamic} не выполняется проверка типов компилятором \cite{book:troelsen2012proCSharp}.

\begin{minted}[mathescape,
               linenos,
               numbersep=5pt,
               gobble=2,
               frame=lines,
               framesep=2mm]{csharp}
    class Program {
        static void Main(string[] args) {
            dynamic dyn = 1;
            object obj = 1;

            // Rest the mouse pointer over dyn and obj to see their
            // types at compile time.
            System.Console.WriteLine(dyn.GetType());
            System.Console.WriteLine(obj.GetType());
        }
    }
\end{minted}

В результате мы получим один и тот же тип для обеих переменных.
\begin{verbatim}
System.Int32
System.Int32
\end{verbatim}
    Чтобы заметить разницу между \textit{dynamic} и \textit{object}, можно рассмотреть следующий пример.

\begin{minted}[mathescape,
               linenos,
               numbersep=5pt,
               gobble=2,
               frame=lines,
               framesep=2mm]{csharp}
dyn = dyn + 3;  
obj = obj + 3;  
\end{minted}

Так как объект \textit{obj} имеет тип \textit{object}, который не поддерживает операцию прибавления, мы получим ошибку компиляции. С другой стороны, переменная \textit{dyn} имеет при компиляции тип \textit{dynamic}, который тоже не поддерживает операцию прибавления, но он откладывает проверку на момент времени выполнения. При выполнении же, мы обнаруживаем тип \textit{System.Int32}, на котором успешно реализуем требуемую операцию.

\subsubsection{Scala}

Ещё одним представителем статически типизированных языков является Scala. В качeстве экспериментальной возможности, начиная со Scala 2.10, был введён trait Dynamic. С его помощью, появляется возможность отключать статическую проверку типов, при выполнении ряда условий. Если у нас есть выражение \mintinline{scala}{qual.sel}, на котором статическая проверка типов завершилась неудачно, у нас есть возможность успешно завершить типизацию, если \mintinline{scala}{qual} удовлетворяет trait Dynamic, а \mintinline{scala}{sel} не является одним из следующих applyDynamic, applyDynamicNamed, selectDynamic, или updateDynamic, то текущий вызов переписывается согласно правилам, подробно описанным в \cite{scala:sipDynamicProposal}.

% Примером реализации trait Dynamic, может служить класс \textit{MyRouter}.

% \begin{minted}[mathescape,
%                linenos,
%                numbersep=5pt,
%                gobble=2,
%                frame=lines,
%                framesep=2mm]{scala}
%     class MyRouter extends Dynamic {
%         def selectDynamic(name: String): T = {}
%         def updateDynamic(name: String)(value: T): Unit = {}
%         def applyDynamic(methodName: String)(args: Any*) {
%             println(s"You called '$methodName' method with " +
%             s"following arguments: ${args mkString ", "}")
%         }
%         def applyDynamicNamed(name: String)(args: (String, Any)*) {
%             println(s"You called '$name' method with " +
%                 s"following argiuments: 
%                 ${args map (a=>a._1+"="+a._2) mkString ","}")
%         }
%     }
% \end{minted}

У trait Dynamic есть реализация \textit{js.Dynamic}, которая используется в Scala.JS. С её помощью можно реализовывать удобные и понятные конструкции, при взаимодействии с объектной моделью документа. В качестве примера, приведём описанный в \cite{art:doeraene2013scala} пример типизированный работы с объектной моделью.

\begin{minted}[mathescape,
               linenos,
               numbersep=5pt,
               gobble=2,
               frame=lines,
               framesep=2mm]{scala}
    object Window extends js.GlobalScope {
        val document: DOMDocument
    }
    trait DOMDocument extends js.Object {
        def getElementById(id: js.String): HTMLElement
    }
    trait HTMLElement extends js.Object {
        def appendChild(child: HTMLElement): Unit
    }
    class Image extends HTMLElement {
        var src: js.String
    }
    object Main {
        def main(): Unit = {
            val playground = Window.document.getElementById("playground")
            val img = new Image
            img.src = "./path/to/img.png"
            playground.appendChild(img)
        }
    }
\end{minted}

Такой код, может быть упрощён с помощью использования динамической типизации.

\begin{minted}[mathescape,
               linenos,
               numbersep=5pt,
               gobble=2,
               frame=lines,
               framesep=2mm]{scala}
    object Main {
        def main(): Unit = {
            val g = js.Dynamic.global
            val playground = g.document.getElementById("playground")
            val img = js.Dynamic.newInstance(g.Image)()
            img.src = "./path/to/img.png"
            playground.appendChild(img)
        }
    }
\end{minted}

\subsubsection{Kotlin}
Kotlin является статически типизированным языком программирования. Начиная с версии 1.1, в нём появилась 
%не экспериментальная 
поддержка компиляции в JavaScript. При компиляции в JavaScript, появляется возможность использования типа \textit{dynamic} \cite{kotlin:dynamicType}. У этого типа есть следующие особенности:

\begin{itemize}
    \item Значение данного типа может быть присвоено любой переменной, и передано всюду, в качестве любого параметра.
    \item Любое значение может быть присвоено переменной имеющей тип \textit{dynamic}, или передано в качестве аргумента, который ожидал тип \textit{dynamic} на входе.
    \item Никаких проверок на нулевой указатель не производится.
\end{itemize}

Однако, в настоящее время, тип \textit{dynamic} Не поддерживается при компиляции в байткод виртуальной машины Java.

\subsection{Осуществление вызовов и Java платформа}

В языке Java поля и методы можно разделить на две группы \cite{java:horstmann2012core}. Обычные поля ассоциированы с конкретным экземпляром класса - объектом. С другой стороны, статические поля ассоциировны с классом, и общие для всех его экземпляров. Внутри статических методов мы имеем право взаимодейстовать только со статическими полями. Обычные методы имюеют права взаимодейстовать как с полями текущего экземпляра класса, так и со статическими полями данного класса. Важно заметить, что статичность поля или метода никак не связано со статическим разрешением вызова. В языке Java, на этапе компиляции можно определеить, осуществляем мы вызов статического или обычного метода класса (поля), таким образом все вызовы разрешаются статически.

Для осуществления статически разрешаемых вызовов методов и взаимодействия с полями, в байт коде Java предназначены следующие инструкции \cite{book:yellin1996java}:

\begin{itemize}
    \item \textbf{invokespecial} --- используется для создания новых экземпляров классов, вызовов приватных методов, и методов родительского класса.
    \item \textbf{invokestatic} --- используется для вызова статических методов
    \item \textbf{invokeinterface} --- используется для вызова методов интерфейса.
    \item \textbf{invokevirtual} --- используется для вызова всех остальных методов.
    \item \textbf{getfield}, \textbf{getstatic} --- используется для получения поля объекта или поля класса соответственно.
    \item \textbf{putfield}, \textbf{putstatic} --- используется для установки значения поля объекта или поля класса соответственно.
\end{itemize}


Для поддержки динамических языков на платформе JVM, в JSR 292, была предложена новая байткод инструкция \textit{invokedynamic}, которая поддерживает эффективное и гибкое решение выполнения вызовов, в условиях отсутствия статической информации о типах \cite{java:JSR292rosejsr}.

Инструкция \textit{invokedynamic} осуществляет вызов метода, на который ссылается специальный объект, называемый точкой вызова (call site). Этот объект получается путём вызова специальной загрузочной функции (bootstrap method), ассоциированной с каждой \textit{invokedynamic} инструкцией \cite{book:yellin1996java}. Путём создания специального алгоритма поведения загрузочной функции, у нас появляется возможность, во время выполнения программы, подстраиваясь под актуальную типовую информацию, производить вызов нужных методов.


В языке Java поддерживается \textit{рефлексия} --- механизм исследования данных о программе, во время её выполнения. Она осуществляется при помощи Java Reflection API. Основной список информации, который можно получить с помощью интерфейса API \cite{java:forman2004javaReflectionsInAction}:
%С его помощью, можно получить информацию об ок типе объекта во время исполнения, получить 

\begin{itemize}
    \item Определить класс объекта во время исполнения.
    \item Получить список полей и методов класса.
    \item Получить информацию о типах аргументов метода.
    \item Вызвать требуемый метод с конкретными аргументами.
\end{itemize}

Однако, стоит отменить, что некоторые операции Reflection API выполняются долгое время.


ПРИМИТИВНЫЕ ТИПЫ В JAVA и ИХ АНАЛОГИ В КОТЛИН


\subsection{Постановка задачи}

Чтобы сделать согласованной работу компиляции в JavaScript и в байткод виртуальной машины Java, возникает необходимость реализовать поддержку типа \textit{dynamic} при компиляции на Java платформе.

Для выполнения этой цели, можно выделить следующие подзадачи.
\begin{itemize}
    \item Выработать правила разрешения перегрузок.
    \item Исследовать возможность поддержки совместимости правил с правилами других JVM языков.
    \item Реализация поддержки в компиляторе языка Kotlin под JVM.
    \item Оценка производительности.
\end{itemize}

