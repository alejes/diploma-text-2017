\section{Обзор литературы}

При разработке программного обеспечения часто используются различные методы, которые помогают убедиться что программная система ведёт себя в соответствии с некоторой спецификацией. Одним из таких методов является \textit{система типов}. Согласно \cite{book:pierce2002types}, для неё можно дать следующее определение:


\begin{definition}
Система типов --- это гибко управляемый синтаксический метод доказательства отсутствия в программе определенных видов поведения при помощи классификации выражений языка по разновидностям вычисляемых ими значений.
\end{definition}

% Одним из важных свойств этого определения является упор на классификацию термов, согласно значениям, в которые они могут быть вычислены.

\subsection{Виды типизации в языках программирования}

В зависимости от системы типов, языки программирования можно рассматривать как представителей одной из следующих групп.
\begin{itemize}
%\itemsep-1mm
\item Языки со статической типизацией (static typing languages).
\item Языки с динамической типизацией (dynamic typing languages).
\item Языки с постепенной типизацией (gradual typing  languages).
\end{itemize}



Языки со статической типизацией отличает связывание переменных, параметров подпрограмм и возвращаемых значений функций с типом в момент объявления, причём этот тип нельзя будем изменить позднее. Таким образом, в момент компиляции мы знаем типы всех выражений. Такое знание позволяет нам проводить некоторые оптимизации и некоторый анализ, на основе которого можно предоставлять пользователю подсказки в рамках Интегрированной Среды Разработки (ИСР).

В языках с динамической типизацией, связывание происходит в момент присваивания значения, которое выполняется во время выполнения программы. Одна и та же переменная может быть связана с разными типами, в зависимости от логики программы. Рассмотрим следующий пример.

\vskip4pt

\begin{minted}[mathescape,
               linenos,
               numbersep=5pt,
               gobble=2,
               frame=lines,
               framesep=2mm]{csharp}
    class A {
        method1()
    }
    class B {
        method1()
    }

    x.method1()
\end{minted} 

\vskip4pt

%\begin{algorithm}[H]
%\SetAlgoLined
%\DontPrintSemicolon
%\KwData{слово $w={a^{{\delta _1}}}{a^{{\delta _2}}} \ldots {a^{{\delta _k}}}%({\delta _i} \in \{ -1,1\}, k \geqslant 0 )$}
%\KwResult{$G’=(X,V)$ with $V\subseteq U$ such that $G’^{tc}$ is an interval order.}
%\Begin{
%	текущая вершина $\leftarrow$ вершина помеченная символом I\;
%	\For{$i\leftarrow 1$ \KwTo $k$}{
%		\uIf{$\delta_k=1$}{
%			текущая вершина $\leftarrow$ вершина в которую можно придти перейдя %из текущей вершины 	\textit{в направлении, указанном стрелкой} 	
%		}
%		\uElse{
%			текущая вершина $\leftarrow$ вершина в которую можно придти перейдя %из текущей вершины 			в направлении, \textit{противоположном} указанному %стрелкой
%		}
%	}
%}
%\caption{Представление слов как вершин графа циклической группы}
%\end{algorithm}

В зависимости от типа переменной \textit{x}, за строкой \textit{x.method1()} может стоять вызов различных методов - либо из класса A, либо из класса B. В случае, если \textit{x} окажется представителем типа, для которого не определён метод \textit{method1()}, вызов должен завершиться с ошибкой. При динамической типизации мы ограничены как в проведении оптимизаций, так и в предоставлении подсказок пользователю в рамках ИСР. Это происходит потому что в большинстве случаев, до процесса выполнения, мы ничего не знаем о типе переменной \textit{x}.

%\begin{definition}
    %Процесс определения назначения операции, базирующийся на типе или значениях составляющих его выражений называют связыванием.
%\end{definition}
%Например, назначение вызова метода, основывается на типе его аргументов, и типе объекта, на котором мы вызваем этот метод. Заметим, что связывание выражений, типы которых можно определить во время компиляции, можно тоже провести во время компиляции. Такой процесс называют \textit{статическим связыванием}. С другой стоороны, если типы не всех элементов операции мы можем определить во время компиляции (например часть из них имееет тип \textit{dynamic}), то мы можем вести  речь про \textit{динамическое связывание} \cite{csharp:languageSpecification}.

Постепенная типизация представляет собой систему типов, в которой часть переменных и выражений может быть типизированна, и их корректность проверяется в момент компиляции, а часть может быть не типизированна, и об ошибках типизации в них мы узнаем в момент исполнения \cite{gradual:siek2006gradual} \cite{gradual:siek2007gradual}. При такой типизации мы можем использовать преимущества как статической, так и динамической типизации. Часть кода мы можем типизировать и выполнять над ним некоторые проверки ещё в момент компиляции. Также компилятор нам может обеспечивать некоторый набор оптимизаций, положительно влияющих для ускорения кода. В то же время, мы можем получить возможность выразить в рамках нашего языка некоторые удобные конструкции или упростить их написание.

\begin{itemize}
    \item Можно выразить \textbf{eval} - функцию, которая отображает код программы записанный в строковом виде, в результат выполнения этого кода, в соответствии с текущими значениями окружающих объектов.
    \item Упрощается реализация предметно-ориентированных языков - языков упрощающих решение прикладных задания в некоторой специализированной области.
    \item Удобная работа с объектной моделью документа (ОМД) - программным интерфейсом, позволяющим унифицировано работать с HTML-, XHTML-, и XML-документами.
\end{itemize}

Возможны два подхода к постепенной типизации. У нас изначально может быть статически типизированный язык, в котором, для некоторых выражений мы будем помечать, что их тип будет известен только в момент выполнения. Таким путём пошли языки C{\#}, Dart. Противоположным подходом является ситуация, когда у нас есть динамически типизированный язык, в котором мы добавляем возможность вводить некоторые ограничения на типы. Эти ограничения могут проверяться во время выполнения, или в момент компиляции, в зависимости от реализации языка программирования. Таким путём пошли языки PHP 7, TypeScript, Python.

При реализации постепенной типизации в статически типизированных языках, обычно вводят специальный тип, называемый \textit{dynamic}, используемый для представления статически неизвестного типа. У нас изменяется понятие эквивалентности типов, добавлением отношения \textit{согласованности}, которое говорит что динамический тип согласован с любым другим. Заметим, что это отношение не транзитивно, иначе из него можно было бы вывести что любой тип согласован с любым другим.


\subsection{Постепенная типизация в языках программирования}

В данной главе мы рассмотрим примеры введения постепенной типизации как в статически, так и в динамически типизированные языки.
\subsubsection{PHP 7 и Python 3.5}

PHP является динамическим языком. В его седьмой версии добавили возможность аннотировать возвращаемое значение и аргументы функций скалярными типами int, float, string и bool \cite{wiki:phpScalarTypeHints}. В предыдущих версиях также поддерживалась проверка аргументов на то, что они являются массивом, корректным вызываемым типом, экземпляром какого-то класса или реализуют требуемый интерфейс \cite{wiki:phpTypeHints}.

\begin{minted}[mathescape,
               linenos,
               numbersep=5pt,
               gobble=2,
               frame=lines,
               framesep=2mm]{php}
    <?php        
        function add(int $a, int $b): int {
           return $a + $b;
        }
        var_dump(add(1, 2)); // int(3)
    ?>
\end{minted}
        %// floats are truncated by default
        %var_dump(add(1.5, 2.5)); // int(3)
 
       % /%/strings convert if there's a number part
        %var_dump(add("1", "2")); // int(3)

Все проверки типов в PHP происходят во время исполнения. При несоответствии типов в PHP 5 будет обрабатываться фатальная ошибка, а в PHP 7 будет выбрасываться исключение.% \textbf{TypeError}.

%\subsubsection{Python}
Python является динамическим языком, и начиная с версии 3.5, в нём можно аннотировать аргументы и возвращаемое значение функций\cite{wiki:pythonPep484TypeHints}. В типах можно выражать и какие-то более сложные составные конструкции, например, можно составить тип суммы типов. %выглядит так.
%\begin{minted}[mathescape,
               %linenos,
               %numbersep=5pt,
               %gobble=2,
               %frame=lines,
               %framesep=2mm]{python}
    %from typing import Union
%    
    %def handle_employees(e: Union[Employee, Sequence[Employee]]) -> None:
        %if isinstance(e, Employee):
            %e = [e]
        %...
%\end{minted}
Python не производит никаких проверок типов, однако, их можно осуществить при помощи сторонних средств. Например, с помощью инструмента статической проверки типов mypy \cite{python:mypyHomepage} или инструментов входящих в ИСР JetBrains PyCharm \cite{python:PyCharmHomepage}.

\subsubsection{Groovy}

Groovy является динамическим языком. Для обеспечения частичной типизации, в нём есть два механизма. Рассмотрим пример динамического кода на этом языке.

\begin{minted}[mathescape,
               linenos,
               numbersep=5pt,
               gobble=2,
               frame=lines,
               framesep=2mm]{groovy}
    class A {
        def foo(x) {
            return x + 1
        }
    }
\end{minted}

Мы можем, аналогично предыдущим языкам, проаннотировать все его компоненты типами.

\begin{minted}[mathescape,
               linenos,
               numbersep=5pt,
               gobble=2,
               frame=lines,
               framesep=2mm]{groovy}
    class A {
        int foo(int x) {
            return x + 1
        }
    }
\end{minted}

Другим способом является добавление к классу аннотации \textit{@CompileStatic} \cite{groovy:compileStatic}. В проаннотированных таким образом классах, будут осуществлены проверки типов в момент компиляции.



\subsubsection{C{\#}}

    C{\#} является первым представителем языков, которые изначально были статически типизированы. В версии 4.0 в нём добавили возможность помечать некоторые выражения типом \textit{dynamic}. Поведение этого типа, во многом, схоже с поведением типа \textit{object}, который является самым общим типом в иерархии наследования. В частности, переменные помеченные типом \textit{dynamic}, компилируются в тип \textit{object}. Таким образом, тип \textit{dynamic} существует только в процессе компиляции, и отсутствует во время выполнения \cite{msdn:dynamicType}. В операциях, которые содержат в своей части выражения помеченные типом \textit{dynamic} не выполняется проверка типов компилятором \cite{book:troelsen2012proCSharp}. Чтобы лучше понять различия \textit{object} и \textit{dynamic}, рассмотрим следующий пример:

\begin{minted}[mathescape,
               linenos,
               numbersep=5pt,
               gobble=2,
               frame=lines,
               framesep=2mm]{csharp}
    class Program {
        static void Main(string[] args) {
            dynamic dyn = 1;
            object obj = 1;

            // Rest the mouse pointer over dyn and obj to see their
            // types at compile time.
            System.Console.WriteLine(dyn.GetType());
            System.Console.WriteLine(obj.GetType());
        }
    }
\end{minted}

В результате, для обеих переменных мы получим один и тот же тип.

\begin{verbatim}
System.Int32
System.Int32
\end{verbatim}
    Однако разница между \textit{dynamic} и \textit{object}, проявляется в операциях, которые можно над ними совершить.

\begin{minted}[mathescape,
               linenos,
               numbersep=5pt,
               gobble=2,
               frame=lines,
               framesep=2mm]{csharp}
dyn = dyn + 3;  
obj = obj + 3;  
\end{minted}

Так как объект \textit{obj} имеет тип \textit{object}, который не поддерживает операцию прибавления, мы получим ошибку компиляции. С другой стороны, переменная \textit{dyn} имеет при компиляции тип \textit{dynamic}, который тоже не поддерживает операцию прибавления, но откладывает проверку этого до момента выполнения программы. При выполнении, мы обнаруживаем что в динамической переменной лежит объект типа \textit{System.Int32}, на котором мы успешно реализуем требуемую операцию.

\subsubsection{Scala}

Ещё одним представителем статически типизированных языков является Scala. В качестве экспериментальной возможности, начиная со Scala 2.10, был введён trait Dynamic. С его помощью, появляется возможность отключать статическую проверку типов, при выполнении ряда условий. Если у нас есть выражение \mintinline{scala}{qual.sel}, на котором статическая проверка типов завершилась неудачно, у нас есть возможность успешно завершить типизацию. Если \mintinline{scala}{qual} удовлетворяет trait Dynamic, а имя \mintinline{scala}{sel} не совпадает с одним из следующих --- applyDynamic, applyDynamicNamed, selectDynamic, или updateDynamic, то текущий вызов переписывается согласно правилам, подробно описанным в \cite{scala:sipDynamicProposal}.

% Примером реализации trait Dynamic, может служить класс \textit{MyRouter}.

% \begin{minted}[mathescape,
%                linenos,
%                numbersep=5pt,
%                gobble=2,
%                frame=lines,
%                framesep=2mm]{scala}
%     class MyRouter extends Dynamic {
%         def selectDynamic(name: String): T = {}
%         def updateDynamic(name: String)(value: T): Unit = {}
%         def applyDynamic(methodName: String)(args: Any*) {
%             println(s"You called '$methodName' method with " +
%             s"following arguments: ${args mkString ", "}")
%         }
%         def applyDynamicNamed(name: String)(args: (String, Any)*) {
%             println(s"You called '$name' method with " +
%                 s"following argiuments: 
%                 ${args map (a=>a._1+"="+a._2) mkString ","}")
%         }
%     }
% \end{minted}

У trait Dynamic есть реализация \textit{js.Dynamic}, которая используется в Scala.JS. С её помощью можно упростить написание кода, взаимодействующего с объектной моделью документа. В качестве примера, приведём описанный в \cite{art:doeraene2013scala} способ типизированный работы с объектной моделью.

\begin{minted}[mathescape,
               linenos,
               numbersep=5pt,
               gobble=2,
               frame=lines,
               framesep=2mm]{scala}
    object Window extends js.GlobalScope {
        val document: DOMDocument
    }
    trait DOMDocument extends js.Object {
        def getElementById(id: js.String): HTMLElement
    }
    trait HTMLElement extends js.Object {
        def appendChild(child: HTMLElement): Unit
    }
    class Image extends HTMLElement {
        var src: js.String
    }
    object Main {
        def main(): Unit = {
            val playground = Window.document.getElementById("playground")
            val img = new Image
            img.src = "./path/to/img.png"
            playground.appendChild(img)
        }
    }
\end{minted}

Такой код, может быть упрощён с помощью использования динамической типизации.

\begin{minted}[mathescape,
               linenos,
               numbersep=5pt,
               gobble=2,
               frame=lines,
               framesep=2mm]{scala}
    object Main {
        def main(): Unit = {
            val g = js.Dynamic.global
            val playground = g.document.getElementById("playground")
            val img = js.Dynamic.newInstance(g.Image)()
            img.src = "./path/to/img.png"
            playground.appendChild(img)
        }
    }
\end{minted}

\subsubsection{Kotlin}
Kotlin является статически типизированным языком программирования. Начиная с версии 1.1, в нём появилась 
%не экспериментальная 
поддержка компиляции в JavaScript. При компиляции в JavaScript, появляется возможность использования типа \textit{dynamic} \cite{kotlin:dynamicType}. У этого типа есть следующие особенности:

\begin{itemize}
    \item Значение данного типа может быть присвоено любой переменной, и передано всюду, в качестве любого параметра.
    \item Любое значение может быть присвоено переменной имеющей тип \textit{dynamic}, или передано в качестве аргумента, который ожидал тип \textit{dynamic} на входе.
    \item Никаких проверок на нулевой указатель не производится.
\end{itemize}

Однако, в настоящее время, тип \textit{dynamic} не поддерживается при компиляции в байт-код виртуальной машины Java.

%ПРИМИТИВНЫЕ ТИПЫ В JAVA и ИХ АНАЛОГИ В КОТЛИН


\subsection{Постановка задачи}

Чтобы обеспечить поддержку постепенной типизации в языке Kotlin, возникает необходимость реализовать поддержку типа \textit{dynamic} при компиляции на Java платформе.

Для достижения этой цели, можно выделить следующие задачи.
\begin{itemize}
    \item Определить поведение динамических операций.
    \item Выработать правила разрешения перегрузок.
    % \item Исследовать возможность поддержки совместимости правил с правилами других JVM языков.
    \item Реализовать поддержку динамических вызовов в компиляторе языка Kotlin под JVM.
    % \item Реализация сопроводительной библиотеки времени выполнения.
    \item Оценить производительность.
\end{itemize}

