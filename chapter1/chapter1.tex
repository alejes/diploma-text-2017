\section{Обзор литературы}

Для разработки программного обеспечения, используются различные \textit{формальные методы}, которые помогают убедиться что система ведёт себя в соответствии с некоторой спецификацией. Одним из таких методов являются \textit{системы типов}. Согласно \cite{book:pierce2002types}, для них можно дать такое определение:


\begin{definition}
Система типов --- это гибко управляемый синтаксический метод доказательства отсутствия в программе определенных видов поведения при помощи классификации выражений языка по разновидностям вычисляемых ими значений.
\end{definition}

Одним из важных свойств этого определения является упор на классификацию термов, согласно значениям, в которые они могут быть вычислены.

В зависимости от типизации, языки программирования можно рассматривать как представителей одной из следующих групп.
\begin{itemize}
\itemsep-1mm
\item Языки с статической типизацией
\item Языки с динамической типизацией
\item Языки с постепенной типизацией
\end{itemize}



Языки со статической типизацией отличает связывание переменных, параметров подпрограмм и возвращаемых значений функций с типом в момент объявления, и этот тип нельзя будем изменить позднее. Таким образом, в момент компиляции мы знаем типы всех выражений. Такое знание позволяет нам проводить некоторые оптимизации и проводить некоторый анализ, на основе которого предоставлять пользователю некоторые подсказки в рамках Интегрированной Среды Разработки (ИСР).

В языках с динамической типизацией, связывание происходит в момент присваивания  значения, во время выполнения программы. Причём одна и та же переменная может быть связана с разными типами, в зависимости от логики программы. Рассмотрим следующий пример.

\vskip4pt

\begin{minted}[mathescape,
               linenos,
               numbersep=5pt,
               gobble=2,
               frame=lines,
               framesep=2mm]{csharp}
    class A {
        method1()
    }
    class B {
        method1()
    }

    x.method1()
\end{minted}

\vskip4pt

%\begin{algorithm}[H]
%\SetAlgoLined
%\DontPrintSemicolon
%\KwData{слово $w={a^{{\delta _1}}}{a^{{\delta _2}}} \ldots {a^{{\delta _k}}}%({\delta _i} \in \{ -1,1\}, k \geqslant 0 )$}
%\KwResult{$G’=(X,V)$ with $V\subseteq U$ such that $G’^{tc}$ is an interval order.}
%\Begin{
%	текущая вершина $\leftarrow$ вершина помеченная символом I\;
%	\For{$i\leftarrow 1$ \KwTo $k$}{
%		\uIf{$\delta_k=1$}{
%			текущая вершина $\leftarrow$ вершина в которую можно придти перейдя %из текущей вершины 	\textit{в направлении, указанном стрелкой} 	
%		}
%		\uElse{
%			текущая вершина $\leftarrow$ вершина в которую можно придти перейдя %из текущей вершины 			в направлении, \textit{противоположном} указанному %стрелкой
%		}
%	}
%}
%\caption{Представление слов как вершин графа циклической группы}
%\end{algorithm}

В зависимости от типа переменной \textit{x}, вызов \textit{x.method1()} может разрешиться в вызов разных методов - из класса A, класса B, или завершиться с ошибкой, если \textit{x} будет другого типа, для которого не определён метод \textit{method1()}. В этом случае мы ограничены в проведении оптимизаций, и ограничены в предоставлении подсказок пользователю в рамках ИСР, потому что в большинстве случаев, до процесса выполнения мы ничего не знаем о типе переменной \textit{x}.

Постепенная типизация представляет собой систему типов, в которой часть переменных и выражений может быть типизированна, и их корректность проверяется в момент компиляции, а часть может быть не типизированна, и об ошибках типизации в них мы узнаем в момент исполнения. При такой типизации мы можем использовать преимущества статической и динамической типизации. Часть кода мы можем типизировать и верифицировать его в момент компиляции. Также компилятор нам может гарантировать некоторый набор оптимизаций, необходимых для ускорения кода. В то же время, мы можем получить возможность выразить в рамках нашего языка некоторые удобные конструкции:

\begin{itemize}
    \item \textbf{eval} - функцию, которая отображает код программы записанный в строковом виде, в результат выполнения этого кода в текущем окружении
    \item Упрощается реализация предметно-ориентированных языков - языков упрощающих решение прикладных задания в некоторой специализированной области
    \item TODO DOM  ОБЪЯСНИ СЛОВАМИ!!!
\end{itemize}

Возможны два подхода к постепенной типизации. У нас изначально может быть статически типизированный язык, и в нём, для некоторых выражений мы будем помечать, что их тип будет известен только в момент выполнения. Таким путём пошли языки C{\#}, Dart, Perl 6. Противоположным подходом является ситуация, что у нас есть динамически типизированный язык, и мы к нему добавляем некоторые ограничения на типы. Эти ограничения могут проверяться во время выполнения, или в момент компиляции, в зависимости от реализации языка программирования. Таким путём пошли языки PHP 7 , TypeScript, Python.

При реализации постепенной типизации, обычно используется специальный тип, называемый \textit{dynamic}, для представления статически неизвестного типа. Также у нас изменяется понятие эквивалентности типов, добавлением отношения \textit{согласованности}, которое говорит что динамический тип согласован с любым другим. Заметим, что это отношение не транзитивно, иначе из него можно было бы вывести что любой тип согласован с любым другим.

Посмотрим как реализованна постепенная типизация в различных языках.

\subsection{PHP 7}

PHP является динамическим языком. В его седьмой версии добавили возможность аннотировать возвращаемое значение и аргументы функций типами \cite{wiki:phpScalarTypeHints}.

\begin{minted}[mathescape,
               linenos,
               numbersep=5pt,
               gobble=2,
               frame=lines,
               framesep=2mm]{php}
    <?php        
        function add(int $a, int $b): int {
           return $a + $b;
        }
        var_dump(add(1, 2)); // int(3)
        // floats are truncated by default
        var_dump(add(1.5, 2.5)); // int(3)
 
        //strings convert if there's a number part
        var_dump(add("1", "2")); // int(3)
    ?>
\end{minted}

\subsection{Python}
Аналогично PHP 7, в Python также можно аннотировать аргументы и возвращаемое значение \cite{wiki:pythonPep484TypeHints}. В типах можно выражать и какие-то более сложные составные конструкции, например тип суммы типов выглядит так.
\begin{minted}[mathescape,
               linenos,
               numbersep=5pt,
               gobble=2,
               frame=lines,
               framesep=2mm]{python}
    from typing import Union
    
    def handle_employees(e: Union[Employee, Sequence[Employee]]) -> None:
        if isinstance(e, Employee):
            e = [e]
        ...
\end{minted}


\subsection{C{\#}}

    C{\#} является первым представителем языков, которые изначально были статически типизированы. В версии 4.0 в нём добавили возможность помечать некоторые выражения типом \textit{dynamic}. Поведение этого типа, во многом, схоже с поведением типа \textit{object}, являющимся самым общим типом в иерархии наследования. В частности, переменные типа \textit{dynamic}, компилируются в тип \textit{object}. Поэтому, тип  \textit{dynamic} существует только в процессе компиляции, и отсутствует во время выполнения. В операциях, которые содержат в своей части выражения помеченные типом \textit{dynamic} не выполняется проверка типов компилятором \cite{msdn:dynamicType}.

\begin{minted}[mathescape,
               linenos,
               numbersep=5pt,
               gobble=2,
               frame=lines,
               framesep=2mm]{csharp}
    class Program {
        static void Main(string[] args) {
            dynamic dyn = 1;
            object obj = 1;

            // Rest the mouse pointer over dyn and obj to see their
            // types at compile time.
            System.Console.WriteLine(dyn.GetType());
            System.Console.WriteLine(obj.GetType());
        }
    }
\end{minted}

В результате мы получим один и тот же тип для обеих переменных.
\begin{verbatim}
System.Int32
System.Int32
\end{verbatim}
Чтобы заметить разницу между \textit{dynamic} и \textit{object}, можно рассмотреть следующий пример.

\begin{minted}[mathescape,
               linenos,
               numbersep=5pt,
               gobble=2,
               frame=lines,
               framesep=2mm]{csharp}
dyn = dyn + 3;  
obj = obj + 3;  
\end{minted}

Так как объект \textit{obj} имеет тип \textit{object}, который не поддерживает операцию прибавления, мы получим ошибку компиляции. С другой стороны, переменная \textit{dyn} имеет при компиляции тип \textit{dynamic}, который тоже не поддерживает операцию прибавления, но он откладывает проверку на момент времени выполнения. При выполнении же, мы обнаруживаем тип \textit{System.Int32}, на котором успешно реализуем требуемую операцию.