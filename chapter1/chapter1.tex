\section{Обзор литературы}

Для разработки программного обеспечения, используются различные \textit{формальные методы}, которые помогают убедиться что система ведёт себя в соответствии с некоторой спецификацией. Одним из таких методов являются \textit{системы типов}. Согласно \cite{book:pierce2002types}, для них можно дать такое определение:


\begin{definition}
Система типов --- это гибко управляемый синтаксический метод доказательства отсутствия в программе определенных видов поведения при помощи классификации выражений языка по разновидностям вычисляемых ими значений.
\end{definition}

Одним из важных свойств этого определения является упор на классификацию термов, согласно значениям, в которые они могут быть вычислены.

В зависимости от типизации, языки программирования можно рассматривать как представителей одной из следующих групп.
\begin{itemize}
\itemsep-1mm
\item Языки с статической типизацией
\item Языки с динамической типизацией
\item Языки с постепенной типизацией
\end{itemize}



Языки со статической типизацией отличает связывание переменных, параметров подпрограмм и возвращаемых значений функций с типом в момент объявления, и этот тип нельзя будем изменить позднее. Таким образом, в момент компиляции мы знаем типы всех выражений. Такое знание позволяет нам проводить некоторые оптимизации и проводить некоторый анализ, на основе которого предоставлять пользователю некоторые подсказки в рамках Интегрированной Среды Разработки (ИСР).

В языках с динамической типизацией, связывание происходит в момент присваивания  значения, во время выполнения программы. Причём одна и та же переменная может быть связана с разными типами, в зависимости от логики программы. Рассмотрим следующий пример.

\vskip4pt

\begin{minted}[mathescape,
               linenos,
               numbersep=5pt,
               gobble=2,
               frame=lines,
               framesep=2mm]{csharp}
    class A {
        method1()
    }
    class B {
        method1()
    }

    x.method1()
\end{minted}

\vskip4pt

%\begin{algorithm}[H]
%\SetAlgoLined
%\DontPrintSemicolon
%\KwData{слово $w={a^{{\delta _1}}}{a^{{\delta _2}}} \ldots {a^{{\delta _k}}}%({\delta _i} \in \{ -1,1\}, k \geqslant 0 )$}
%\KwResult{$G’=(X,V)$ with $V\subseteq U$ such that $G’^{tc}$ is an interval order.}
%\Begin{
%	текущая вершина $\leftarrow$ вершина помеченная символом I\;
%	\For{$i\leftarrow 1$ \KwTo $k$}{
%		\uIf{$\delta_k=1$}{
%			текущая вершина $\leftarrow$ вершина в которую можно придти перейдя %из текущей вершины 	\textit{в направлении, указанном стрелкой} 	
%		}
%		\uElse{
%			текущая вершина $\leftarrow$ вершина в которую можно придти перейдя %из текущей вершины 			в направлении, \textit{противоположном} указанному %стрелкой
%		}
%	}
%}
%\caption{Представление слов как вершин графа циклической группы}
%\end{algorithm}

В зависимости от типа переменной \textit{x}, вызов \textit{x.method1()} может разрешиться в вызов разных методов - из класса A, класса B, или завершиться с ошибкой, если \textit{x} будет другого типа, для которого не определён метод \textit{method1()}. В этом случае мы ограничены в проведении оптимизаций, и ограничены в предоставлении подсказок пользователю в рамках ИСР, потому что в большинстве случаев, до процесса выполнения мы ничего не знаем о типе переменной \textit{x}.

Постепенная типизация представляет собой систему типов, в которой часть переменных и выражений может быть типизированна, и их корректность проверяется в момент компиляции, а часть может быть не типизированна, и об ошибках типизации в них мы узнаем в момент исполнения. При такой типизации мы можем использовать преимущества статической и динамической типизации. Часть кода мы можем типизировать и верифицировать его в момент компиляции. Также компилятор нам может гарантировать некоторый набор оптимизаций, необходимых для ускорения кода. В то же время, мы можем получить возможность выразить в рамках нашего языка некоторые удобные конструкции:

\begin{itemize}
    \item \textbf{eval} - функцию, которая отображает код программы записанный в строковом виде, в результат выполнения этого кода в текущем окружении
    \item Упрощается реализация предметно-ориентированных языков - языков упрощающих решение прикладных задания в некоторой специализированной области
    \item TODO DOM  ОБЪЯСНИ СЛОВАМИ!!!
\end{itemize}

Возможны два подхода к постепенной типизации. У нас изначально может быть статически типизированный язык, и в нём, для некоторых выражений мы будем помечать, что их тип будет известен только в момент выполнения. Таким путём пошли языки C{\#}, Dart, Perl 6. Противоположным подходом является ситуация, что у нас есть динамически типизированный язык, и мы к нему добавляем некоторые ограничения на типы. Эти ограничения могут проверяться во время выполнения, или в момент компиляции, в зависимости от реализации языка программирования. Таким путём пошли языки PHP 7 , TypeScript, Python.

При реализации постепенной типизации, обычно используется специальный тип, называемый \textit{dynamic}, для представления статически неизвестного типа. Также у нас изменяется понятие эквивалентности типов, добавлением отношения \textit{согласованности}, которое говорит что динамический тип согласован с любым другим. Заметим, что это отношение не транзитивно, иначе из него можно было бы вывести что любой тип согласован с любым другим.

Посмотрим как реализованна постепенная типизация в различных языках.

\subsection{PHP 7}

В PHP 7 добавили возможность аннотировать возвращаемое значение и аргументы функций типами \cite{wiki:phpScalarTypeHints}.

\begin{minted}[mathescape,
               linenos,
               numbersep=5pt,
               gobble=2,
               frame=lines,
               framesep=2mm]{php}
    <?php        
        function add(int $a, int $b): int {
           return $a + $b;
        }
        var_dump(add(1, 2)); // int(3)
        // floats are truncated by default
        var_dump(add(1.5, 2.5)); // int(3)
 
        //strings convert if there's a number part
        var_dump(add("1", "2")); // int(3)
    ?>
\end{minted}

\subsection{Python}
Аналогично PHP 7, в Python также можно аннотировать аргументы и вовзвращаемое значение \cite{wiki:pythonPep484TypeHints}. В типах можно выражать и какие-то более сложные составные конструкции, например тип суммы типов выглядит так.
\begin{minted}[mathescape,
               linenos,
               numbersep=5pt,
               gobble=2,
               frame=lines,
               framesep=2mm]{python}
    from typing import Union
    
    def handle_employees(e: Union[Employee, Sequence[Employee]]) -> None:
        if isinstance(e, Employee):
            e = [e]
        ...
\end{minted}